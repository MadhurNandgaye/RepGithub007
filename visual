import React, { useState, useEffect, useMemo, useCallback } from 'react';
import axios from 'axios';
import {
  Container,
  Typography,
  Box,
  Card,
  CardContent,
  Table,
  TableBody,
  TableCell,
  TableContainer,
  TableHead,
  TableRow,
  Paper,
  Chip,
  Alert,
  AlertTitle,
  CssBaseline,
  ThemeProvider,
  createTheme,
  CircularProgress,
  Tooltip,
  Button,
  List,
  ListItem,
  ListItemButton,
  ListItemIcon,
  ListItemText,
  TextField,
  Select,
  MenuItem,
  FormControl,
  InputLabel,
  IconButton,
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  Grid,
  InputAdornment,
} from '@mui/material';
import CheckCircleOutlineIcon from '@mui/icons-material/CheckCircleOutline';
import WarningAmberIcon from '@mui/icons-material/WarningAmber';
import ErrorOutlineIcon from '@mui/icons-material/ErrorOutline';
import ArrowUpwardIcon from '@mui/icons-material/ArrowUpward';
import ArrowDownwardIcon from '@mui/icons-material/ArrowDownward';
import HorizontalRuleIcon from '@mui/icons-material/HorizontalRule';
import AnalyticsIcon from '@mui/icons-material/Analytics';
import BugReportIcon from '@mui/icons-material/BugReport';
import MemoryIcon from '@mui/icons-material/Memory';
import DeveloperBoardIcon from '@mui/icons-material/DeveloperBoard';
import DashboardIcon from '@mui/icons-material/Dashboard';
import TableChartIcon from '@mui/icons-material/TableChart';
import NotificationsIcon from '@mui/icons-material/Notifications';
import AutoFixHighIcon from '@mui/icons-material/AutoFixHigh';
import PersonIcon from '@mui/icons-material/Person';
import { Brightness4 as Brightness4Icon, Brightness7 as Brightness7Icon } from '@mui/icons-material';
import CalendarTodayIcon from '@mui/icons-material/CalendarToday';
import FilterListIcon from '@mui/icons-material/FilterList';


import {
  AreaChart,
  Area,
  ResponsiveContainer,
  Tooltip as RechartsTooltip,
  XAxis,
  YAxis,
} from 'recharts';
import { blueGrey } from '@mui/material/colors';


/**
 * Interface for the filters that can be applied to the data fetch.
 */
interface DataFilters {
  project?: string;
  server?: string; // This will not be sent to the new API, but kept for UI state
  startDate?: Date | null;
  endDate?: Date | null;
  timespan?: string | null; // New field for the API
}

/**
 * Interface for the structure of the data records.
 * This will now represent a simplified book item for demonstration.
 */
interface BookResult {
  id: string;
  title: string;
  authors: string;
  publishedDate: string;
  description: string;
  thumbnail: string;
}

/**
 * Interface for the structure of an Endpoint.
 * This will be simulated based on the success of the Google Books API call.
 */
interface Endpoint {
  id: string;
  name: string;
  url: string;
  baselineLatency: number;
  internalLatency: number | null;
  externalLatency: number | null;
  internalHealth: 'Red' | 'Yellow' | 'Green' | 'Unknown';
  externalHealth: 'Red' | 'Yellow' | 'Green' | 'Unknown';
  lastChecked: string | null;
  internalLatencyHistory: { value: number; timestamp: Date }[];
  externalLatencyHistory: { value: number; timestamp: Date }[];
  errorRate: number;
  traffic: number;
  errorRateHistory: { value: number; timestamp: Date }[];
  serverName: string;
  projectName: string;
}

// New API endpoint
const MONITOR_API_URL = 'https://localhost:7278/Monitor/GetDataFromAppInsights';

/**
 * Fetches data from the new Monitor API using a POST request.
 *
 * @param {DataFilters} filters - An object containing filters for the data.
 * @returns {Promise<BookResult[]>} A promise that resolves with an array of BookResult objects.
 */
const fetchFilteredDataFromAPI = async (filters: DataFilters): Promise<BookResult[]> => {
  const projectName = filters.project || '';
  const fromDate = filters.startDate ? filters.startDate.toISOString() : null;
  const toDate = filters.endDate ? filters.endDate.toISOString() : null;
  const timespan = filters.timespan || null; // Use the provided timespan

  if (!projectName) {
    console.log('fetchFilteredDataFromAPI: No project filter provided, skipping API call.');
    return [];
  }

  const payload = {
    projectName: projectName,
    fromDate: fromDate,
    toDate: toDate,
    timespan: timespan,
  };

  console.log('fetchFilteredDataFromAPI: Making POST request to:', MONITOR_API_URL);
  console.log('fetchFilteredDataFromAPI: Payload being sent:', payload);

  try {
    // NOTE: This API call will likely fail in the browser due to CORS and localhost.
    // This is for demonstration of the request structure.
    const response = await axios.post(MONITOR_API_URL, payload, {
      headers: {
        'Content-Type': 'application/json',
      },
      // You might need to adjust withCredentials or other CORS settings depending on your backend
      // withCredentials: true,
    });

    console.log(`fetchFilteredDataFromAPI: API call to ${MONITOR_API_URL} successful. Response:`, response.data);

    // --- IMPORTANT: Adjust this section based on your actual API response structure ---
    // The following is a placeholder mapping from a hypothetical response structure
    // to the BookResult interface. You will need to replace this with logic
    // that correctly parses data from your 'GetDataFromAppInsights' API.
    if (response.data && Array.isArray(response.data)) {
      // Assuming your API returns an array of objects that can be mapped to BookResult
      return response.data.map((item: any, index: number) => ({
        id: item.id || `mock-id-${index}`,
        title: item.name || `Mock Title for ${projectName}`,
        authors: item.user || 'Unknown User',
        publishedDate: item.timestamp ? new Date(item.timestamp).toISOString().split('T')[0] : 'N/A',
        description: item.message || 'No description available from mock data.',
        thumbnail: 'https://placehold.co/60x80/EEEEEE/AAAAAA?text=Data', // Placeholder image
      }));
    } else if (response.data && typeof response.data === 'object') {
        // If your API returns a single object that might contain a list, adjust here.
        // For now, let's just return a single mock item if the response is a non-array object
        return [{
            id: 'mock-single-id',
            title: `Single Mock Result for ${projectName}`,
            authors: 'API Response',
            publishedDate: new Date().toISOString().split('T')[0],
            description: 'This is a single mock result from the API.',
            thumbnail: 'https://placehold.co/60x80/EEEEEE/AAAAAA?text=Single',
        }];
    }
    // --- End of IMPORTANT section ---

    return []; // Return empty array if no data or unexpected structure
  } catch (error) {
    console.error(`fetchFilteredDataFromAPI: Error fetching data from ${MONITOR_API_URL}:`, error);
    // Return a simulated error response for the UI to display something
    return [{
        id: 'error-mock',
        title: 'Error Fetching Data',
        authors: 'System',
        publishedDate: new Date().toISOString().split('T')[0],
        description: `Failed to load data for ${projectName}. Check console for details.`,
        thumbnail: 'https://placehold.co/60x80/FF0000/FFFFFF?text=Error',
    }];
  }
};


const lightTheme = createTheme({
  typography: {
    fontFamily: 'Inter, sans-serif',
    h4: {
      fontWeight: 700,
      marginBottom: '1rem',
    },
    h5: {
      fontWeight: 600,
      marginBottom: '0.8rem',
    },
    h6: {
      fontWeight: 500,
    },
  },
  palette: {
    mode: 'light',
    primary: {
      main: '#1976d2',
    },
    secondary: {
      main: '#dc004e',
    },
    success: {
      main: '#4caf50',
    },
    warning: {
      main: '#ff9800',
    },
    error: {
      main: '#f44336',
    },
    background: {
      default: '#f4f6f8',
      paper: '#ffffff',
    },
    grey: {
      300: '#e0e0e0',
      500: '#9e9e9e',
    },
  },
  components: {
    MuiCard: {
      styleOverrides: {
        root: {
          borderRadius: 12,
          boxShadow: '0 4px 20px rgba(0,0,0,0.05)',
        },
      },
    },
    MuiChip: {
      styleOverrides: {
        root: {
          borderRadius: 8,
          fontWeight: 600,
          minWidth: 80,
          justifyContent: 'center',
        },
      },
    },
    MuiTableCell: {
      styleOverrides: {
        head: {
          fontWeight: 600,
          backgroundColor: '#e0e0e0',
        },
      },
    },
  },
});

const darkTheme = createTheme({
  typography: {
    fontFamily: 'Inter, sans-serif',
    h4: {
      fontWeight: 700,
      marginBottom: '1rem',
    },
    h5: {
      fontWeight: 600,
      marginBottom: '0.8rem',
    },
    h6: {
      fontWeight: 500,
    },
  },
  palette: {
    mode: 'dark',
    primary: {
      main: '#90caf9',
    },
    secondary: {
      main: '#f48fb1',
    },
    success: {
      main: '#81c784',
    },
    warning: {
      main: '#ffb74d',
    },
    error: {
      main: '#e57373',
    },
    background: {
      default: '#121212',
      paper: '#1e1e1e',
    },
    grey: {
      300: '#424242',
      500: '#bdbdbd',
    },
  },
  components: {
    MuiCard: {
      styleOverrides: {
        root: {
          borderRadius: 12,
          boxShadow: '0 4px 20px rgba(0,0,0,0.3)',
        },
      },
    },
    MuiChip: {
      styleOverrides: {
        root: {
          borderRadius: 8,
          fontWeight: 600,
          minWidth: 80,
          justifyContent: 'center',
        },
      },
    },
    MuiTableCell: {
      styleOverrides: {
        head: {
          fontWeight: 600,
          backgroundColor: '#333333',
        },
      },
    },
    MuiIconButton: {
      styleOverrides: {
        root: {
          color: '#ffffff',
        },
      },
    },
    MuiInputAdornment: {
      styleOverrides: {
        root: {
          color: '#ffffff',
        },
      },
    },
    // Added style overrides for TextField to attempt to style native date input icon
    MuiTextField: {
      styleOverrides: {
        root: {
          // Target the native calendar picker indicator for WebKit browsers
          '& .MuiInputBase-input[type="date"]::-webkit-calendar-picker-indicator': {
            filter: 'invert(1)', // Invert color for dark theme
          },
          // Ensure the input text color is white in dark theme
          '& .MuiInputBase-input[type="date"]': {
            color: '#ffffff',
          },
        },
      },
    },
  },
});

// Hardcoded filter options as per user request
const hardcodedProjectNames = ['DTOCRUAT', 'DTOCRDEV', 'DTOCRSSDEV'];
const hardcodedServerNames = ['1', '2', '3'];

const generateInitialFilterOptions = (): { projectNames: string[]; serverNames: string[] } => {
  return {
    projectNames: hardcodedProjectNames,
    serverNames: hardcodedServerNames,
  };
};

const initialFilterOptions = generateInitialFilterOptions();


const getTrend = (history: { value: number; timestamp: Date }[]): 'improving' | 'degrading' | 'stable' | 'unknown' => {
  if (history.length < 2) {
    return 'unknown';
  }

  const current = history[history.length - 1].value;
  const prev = history[history.length - 2].value;

  if (current < prev * 0.9) {
    return 'improving';
  } else if (current > prev * 1.1) {
    return 'degrading';
  } else {
    return 'stable';
  }
};

interface LatencyBarProps {
  currentLatency: number;
  baselineLatency: number;
  health: 'Red' | 'Yellow' | 'Green' | 'Unknown';
  themeMode: 'light' | 'dark';
}

const LatencyBar: React.FC<LatencyBarProps> = ({ currentLatency, baselineLatency, health, themeMode }) => {
  const currentTheme = themeMode === 'light' ? lightTheme : darkTheme;

  let circleColor: string;
  switch (health) {
    case 'Green':
      circleColor = currentTheme.palette.success.main;
      break;
    case 'Yellow':
      circleColor = currentTheme.palette.warning.main;
      break;
    case 'Red':
      circleColor = currentTheme.palette.error.main;
      break;
    default:
      circleColor = currentTheme.palette.grey[500];
      break;
  }

  const ratio = currentLatency / baselineLatency;
  let size = 12;
  if (ratio > 1.5) {
    size = 18;
  } else if (ratio < 0.8) {
    size = 10;
  }

  return (
    <Tooltip title={`Current: ${currentLatency}ms (Baseline: ${baselineLatency}ms)`}>
      <Box
        sx={{
          width: size,
          height: size,
          backgroundColor: circleColor,
          borderRadius: '50%',
          display: 'inline-block',
          verticalAlign: 'middle',
          ml: 1,
          transition: 'all 0.3s ease-in-out',
        }}
      />
    </Tooltip>
  );
};

const OverallSummaryStatus: React.FC<{ totalEndpoints: number; healthyEndpoints: number; yellowEndpoints: number; redEndpoints: number; overallStatus: string }> = ({ totalEndpoints, healthyEndpoints, yellowEndpoints, redEndpoints, overallStatus }) => (
  <Card>
    <CardContent>
      <Typography variant="h5" gutterBottom>
        Overall System Status
      </Typography>
      <Box sx={{ display: 'flex', alignItems: 'center', gap: 2, mb: 2 }}>
        <Chip
          label={overallStatus}
          color={
            overallStatus === 'Operational'
              ? 'success'
              : overallStatus === 'Degraded'
              ? 'warning'
              : 'error'
          }
          sx={{ fontSize: '1rem', padding: '0.5rem 1rem', height: 'auto' }}
        />
        <Typography variant="body1">
          {overallStatus === 'Operational' && 'All monitored endpoints are currently healthy and performing within expected baselines.'}
          {overallStatus === 'Degraded' && `Some endpoints (${yellowEndpoints} yellow) are experiencing degraded performance. Further investigation may be needed.`}
          {overallStatus === 'Critical' && `Critical issues detected! ${redEndpoints} endpoints are experiencing severe problems. Immediate attention required!`}
        </Typography>
      </Box>
      <Typography variant="body2" color="textSecondary">
        Total Endpoints Monitored: {totalEndpoints} | Healthy: {healthyEndpoints} | Degraded: {yellowEndpoints} | Critical: {redEndpoints}
      </Typography>
    </CardContent>
  </Card>
);

const IndividualEndpointStatusTable: React.FC<{ endpoints: Endpoint[]; getStatusProps: Function; getTrendIcon: Function; appliedStartDate: Date | null; appliedEndDate: Date | null; themeMode: 'light' | 'dark' }> = ({ endpoints, getStatusProps, getTrendIcon, appliedStartDate, appliedEndDate, themeMode }) => {
  const filteredEndpoints = useMemo(() => {
    if (!appliedStartDate || !appliedEndDate) {
      return endpoints;
    }
    const start = appliedStartDate;
    const end = appliedEndDate;

    return endpoints.filter(endpoint =>
      endpoint.lastChecked &&
      new Date(endpoint.lastChecked).getTime() >= start.getTime() &&
      new Date(endpoint.lastChecked).getTime() <= end.getTime()
    );
  }, [endpoints, appliedStartDate, appliedEndDate]);

  const getErrorRateColor = (errorCount: number) => {
    const currentTheme = themeMode === 'light' ? lightTheme : darkTheme;
    if (errorCount > 10) return currentTheme.palette.error.main;
    if (errorCount > 3) return currentTheme.palette.warning.main;
    return currentTheme.palette.success.main;
  };

  const getTrafficColor = (traffic: number) => {
    const currentTheme = themeMode === 'light' ? lightTheme : darkTheme;
    if (traffic > 200) return currentTheme.palette.primary.main;
    if (traffic < 50) return currentTheme.palette.warning.main;
    return currentTheme.palette.success.main;
  };

  const calculateAverage = (history: { value: number; timestamp: Date }[], startDate: Date | null, endDate: Date | null) => {
    let filteredHistory = history;
    if (startDate && endDate) {
      filteredHistory = history.filter(point =>
        point.timestamp.getTime() >= startDate.getTime() &&
        point.timestamp.getTime() <= endDate.getTime()
      );
    }

    if (filteredHistory.length === 0) return 'N/A';
    const sum = filteredHistory.reduce((acc, val) => acc + val.value, 0);
    return (sum / filteredHistory.length).toFixed(1);
  };

  return (
    <Card>
      <CardContent>
        <Typography variant="h5" gutterBottom>
          Individual Endpoint Health Status
        </Typography>
        <TableContainer component={Paper} sx={{ borderRadius: 2 }}>
          <Table stickyHeader aria-label="endpoint health table">
            <TableHead><TableRow>
                <TableCell sx={{ minWidth: '25px' }}>No.</TableCell>
                <TableCell sx={{ minWidth: '150px' }}>Endpoint Name</TableCell>
                <TableCell align="center" sx={{ minWidth: '50px' }}>Internal Health</TableCell>
                <TableCell align="center" sx={{ minWidth: '50px' }}>External Health</TableCell>
                <TableCell align="right" sx={{ minWidth: '30px' }}>Internal Latency (ms)</TableCell>
                <TableCell align="right" sx={{ minWidth: '60px' }}>External Latency (ms)</TableCell>
                <TableCell align="right" sx={{ minWidth: '80px' }}>Baseline (ms)</TableCell>
                <TableCell align="right" sx={{ minWidth: '100px' }}>Current Errors</TableCell>
                {/* Removed Avg Errors column */}
                <TableCell align="right" sx={{ minWidth: '80px' }}>Traffic (RPS)</TableCell>
                <TableCell align="center" sx={{ minWidth: '100px' }}>Last Checked</TableCell>
              </TableRow></TableHead>
            <TableBody>{filteredEndpoints.map((endpoint, index) => (
                <TableRow key={endpoint.id}>
                  <TableCell>{index + 1}</TableCell>
                  <TableCell component="th" scope="row">{endpoint.name}</TableCell>
                  <TableCell align="center"><Chip {...getStatusProps(endpoint.internalHealth)} size="small" sx={{ width: 50, fontSize: '0.65rem' }} /></TableCell>
                  <TableCell align="center"><Chip {...getStatusProps(endpoint.externalHealth)} size="small" sx={{ width: 50, fontSize: '0.65rem' }} /></TableCell>
                  <TableCell align="right">
                    <Box display="flex" alignItems="center" justifyContent="flex-end">
                      <Typography variant="body2" sx={{ mr: 1, minWidth: '20px', textAlign: 'right', fontSize: '0.75rem' }}>{endpoint.internalLatency !== null ? endpoint.internalLatency : 'N/A'}</Typography>
                      {endpoint.internalLatency !== null && (<LatencyBar currentLatency={endpoint.internalLatency} baselineLatency={endpoint.baselineLatency} health={endpoint.internalHealth} themeMode={themeMode} />)}
                      {/* Ensure internalLatencyHistory is an array of HistoryDataPoint for getTrend */}
                      {endpoint.internalLatencyHistory && getTrendIcon(getTrend(endpoint.internalLatencyHistory.map(h => ({ ...h, timestamp: h.timestamp instanceof Date ? h.timestamp : new Date(h.timestamp) })) ))}
                    </Box>
                  </TableCell>
                  <TableCell align="right">
                    <Box display="flex" alignItems="center" justifyContent="flex-end">
                      <Typography variant="body2" sx={{ mr: 1, minWidth: '20px', textAlign: 'right', fontSize: '0.75rem' }}>{endpoint.externalLatency !== null ? endpoint.externalLatency : 'N/A'}</Typography>
                      {endpoint.externalLatency !== null && (<LatencyBar currentLatency={endpoint.externalLatency} baselineLatency={endpoint.baselineLatency} health={endpoint.externalHealth} themeMode={themeMode} />)}
                      {/* Ensure externalLatencyHistory is an array of HistoryDataPoint for getTrend */}
                      {endpoint.externalLatencyHistory && getTrendIcon(getTrend(endpoint.externalLatencyHistory.map(h => ({ ...h, timestamp: h.timestamp instanceof Date ? h.timestamp : new Date(h.timestamp) })) ))}
                    </Box>
                  </TableCell>
                  <TableCell align="right">{endpoint.baselineLatency}</TableCell>
                  <TableCell align="right" sx={{ color: getErrorRateColor(endpoint.errorRate), fontWeight: 500 }}>{endpoint.errorRate}</TableCell>
                  <TableCell align="right" sx={{ color: getTrafficColor(endpoint.traffic), fontWeight: 500 }}>{endpoint.traffic}</TableCell>
                  <TableCell align="center">{endpoint.lastChecked ? new Date(endpoint.lastChecked).toLocaleString() : 'N/A'}</TableCell>
                </TableRow>
              ))}</TableBody>
          </Table>
        </TableContainer>
      </CardContent>
    </Card>
  );
};

const NotificationAlerting: React.FC = () => (
  <Card>
    <CardContent>
      <Typography variant="h5" gutterBottom>
        Notification & Alerting
      </Typography>
      <Typography variant="body1" paragraph>
        This Logic App can be configured to send summary status and alerts via various notification mechanisms based on defined thresholds:
      </Typography>
      <Alert severity="info" sx={{ mb: 1 }}>
        <AlertTitle>Email Notifications</AlertTitle>
        Automated emails can be sent to designated recipients or distribution lists for critical alerts (Red status) and daily/weekly performance summaries. This ensures key stakeholders are immediately informed of incidents.
      </Alert>
      <Alert severity="info" sx={{ mb: 1 }}>
        <AlertTitle>RSS Feed</AlertTitle>
        A dedicated RSS feed can be published, allowing users or other monitoring systems to subscribe and receive real-time updates on endpoint health changes, providing a low-friction subscription model.
      </Alert>
      <Alert severity="info">
        <AlertTitle>Subscription-based Notifications</AlertTitle>
        Integration with popular communication and incident management platforms (e.g., Slack, Microsoft Teams, PagerDuty, Opsgenie) can be established to push alerts directly to relevant channels or on-call teams for rapid response.
      </Alert>
    </CardContent>
  </Card>
);

const AutomatedSelfHealingActions: React.FC = () => (
  <Card>
    <CardContent>
      <Typography variant="h5" gutterBottom>
        Automated Self-Healing Actions
      </Typography>
      <Typography variant="body1" paragraph>
        Under predefined conditions (e.g., an endpoint remains 'Red' for more than 5 minutes), this Logic App can trigger automated self-healing resolutions to mitigate issues without manual intervention. These actions are crucial for maintaining application availability:
      </Typography>
      <Alert severity="warning" sx={{ mb: 1 }}>
        <AlertTitle>Auto-Restart Application Service</AlertTitle>
        If an endpoint consistently shows a 'Red' status due to application-level errors (e.g., unhandled exceptions, memory leaks), the Logic App can automatically trigger a restart of the associated application service to clear its state.
      </Alert>
      <Alert severity="warning" sx={{ mb: 1 }}>
        <AlertTitle>IIS App Pool Recycle</AlertTitle>
        For web applications hosted on IIS, if an endpoint becomes unresponsive or shows degraded performance, the Logic App can initiate an.automatic recycle of the relevant IIS application pool, often resolving minor resource contention issues.
      </Alert>
      <Alert severity="warning">
        <AlertTitle>Failover to Secondary Instance</AlertTitle>
        In a multi-instance or high-availability setup, if a primary instance's API endpoint consistently fails, the Logic App could trigger an automated failover to a healthy secondary instance, redirecting traffic and minimizing downtime.
      </Alert>
      <Typography variant="body2" color="textSecondary" sx={{ mt: 2 }}>
        Note: The specific automation steps would involve secure API integrations with cloud providers' APIs (e.g., Azure Resource Manager, AWS CloudWatch/Lambda, GCP Cloud Functions) or on-premise orchestration tools and runbooks.
      </Typography>
    </CardContent>
  </Card>
);

interface User {
  id: string;
  name: string;
  email: string;
  role: string;
  lastLogin: Date;
  department: string;
  contact: string;
}

const loggedInUser: User = {
  id: 'user-123',
  name: 'John Doe',
  email: 'john.doe@example.com',
  role: 'Administrator',
  lastLogin: new Date('2025-07-10T12:00:00Z'),
  department: 'IT Operations',
  contact: '+1-555-123-4567',
};

const UserProfileTable: React.FC = () => {
  return (
    <Card>
      <CardContent>
        <Typography variant="h5" gutterBottom>
          My Profile
        </Typography>
        <TableContainer component={Paper} sx={{ borderRadius: 2 }}>
          <Table aria-label="user profile table">
            <TableBody><TableRow><TableCell component="th" scope="row" sx={{ fontWeight: 'bold', width: '30%' }}>User ID</TableCell><TableCell>{loggedInUser.id}</TableCell></TableRow>
              <TableRow><TableCell component="th" scope="row" sx={{ fontWeight: 'bold' }}>Name</TableCell><TableCell>{loggedInUser.name}</TableCell></TableRow>
              <TableRow><TableCell component="th" scope="row" sx={{ fontWeight: 'bold' }}>Email</TableCell><TableCell>{loggedInUser.email}</TableCell></TableRow>
              <TableRow><TableCell component="th" scope="row" sx={{ fontWeight: 'bold' }}>Role</TableCell><TableCell>{loggedInUser.role}</TableCell></TableRow>
              <TableRow><TableCell component="th" scope="row" sx={{ fontWeight: 'bold' }}>Department</TableCell><TableCell>{loggedInUser.department}</TableCell></TableRow>
              <TableRow><TableCell component="th" scope="row" sx={{ fontWeight: 'bold' }}>Contact</TableCell><TableCell>{loggedInUser.contact}</TableCell></TableRow>
              <TableRow><TableCell component="th" scope="row" sx={{ fontWeight: 'bold' }}>Last Login</TableCell><TableCell>{loggedInUser.lastLogin.toLocaleString()}</TableCell></TableRow>
            </TableBody>
          </Table>
        </TableContainer>
      </CardContent>
    </Card>
  );
};


interface SidebarNavProps {
  onSelectView: (view: string) => void;
  activeView: string;
  themeMode: 'dark' | 'light';
  onLogoutRequest: () => void;
}

const SidebarNav: React.FC<SidebarNavProps> = ({ onSelectView, activeView, themeMode, onLogoutRequest }) => {
  const currentTheme = themeMode === 'light' ? lightTheme : darkTheme;
  const navItems = [
    { id: 'table', text: 'Endpoint Table', icon: <TableChartIcon /> },
    { id: 'error_trends', text: 'Error Trends', icon: <DeveloperBoardIcon /> },
    { id: 'summary', text: 'Overall Summary', icon: <DashboardIcon /> },
    { id: 'filtered_data', text: 'Filtered Data', icon: <FilterListIcon /> }, // New nav item
    { id: 'notifications', text: 'Notifications', icon: <NotificationsIcon /> },
    { id: 'selfHealing', text: 'Self-Healing', icon: <AutoFixHighIcon /> },
    { id: 'user_profile', text: 'User Profile', icon: <PersonIcon /> },
  ];

  return (
    <Box sx={{ width: '154px', flexShrink: 0, bgcolor: 'background.paper', borderRight: 1, borderColor: 'divider', height: '100vh', position: 'sticky', top: 0, p: 1 }}>
      <Typography variant="subtitle1" sx={{ mb: 2, fontWeight: 'bold', color: currentTheme.palette.primary.main, fontSize: '1rem', justifyContent: 'center', textAlign: 'center' }}>
        Views
      </Typography>
      <List>
        {navItems.map((item) => (
          <ListItem key={item.id} disablePadding>
            <ListItemButton
              selected={activeView === item.id}
              onClick={() => onSelectView(item.id)}
              sx={{
                borderRadius: 2,
                flexDirection: 'column',
                alignItems: 'center',
                justifyContent: 'center',
                py: 1.5,
                '&.Mui-selected': {
                  backgroundColor: currentTheme.palette.primary.light,
                  color: currentTheme.palette.primary.contrastText,
                  '& .MuiListItemIcon-root': { color: currentTheme.palette.primary.contrastText }
                },
                '&:hover': {
                  backgroundColor: currentTheme.palette.action.hover,
                },
                color: currentTheme.palette.text.primary,
              }}
            >
              <ListItemIcon sx={{ minWidth: 40, color: 'inherit', mb: 0.5 }}>
                {item.icon}
              </ListItemIcon>
              <ListItemText
                primary={
                  <Typography variant="caption" sx={{ fontSize: '0.75rem', textAlign: 'center', lineHeight: 1.2, color: 'inherit' }}>
                    {item.text}
                  </Typography>
                }
                disableTypography={true}
              />
            </ListItemButton>
          </ListItem>
        ))}
      </List>
      <Box sx={{ mt: 3, px: 1 }}>
        <Button
          variant="outlined"
          color="inherit"
          onClick={onLogoutRequest}
          fullWidth
          sx={{ borderRadius: 2 }}
        >
          Logout
        </Button>
      </Box>
    </Box>
  );
};

interface MiniTrendGraphProps {
  history: { value: number; timestamp: Date }[];
  label: string;
  unit: string;
  color: string;
  appliedStartDate: Date | null;
  appliedEndDate: Date | null;
  themeMode: 'light' | 'dark';
}

const MiniTrendGraph: React.FC<MiniTrendGraphProps> = ({ history, label, unit, color, appliedStartDate, appliedEndDate, themeMode }) => {
  const currentTheme = themeMode === 'light' ? lightTheme : darkTheme;
  const filteredHistory = useMemo(() => {
    if (!appliedStartDate || !appliedEndDate) {
      return history;
    }
    const start = appliedStartDate;
    const end = appliedEndDate;

    return history.filter(point =>
      point.timestamp.getTime() >= start.getTime() &&
      point.timestamp.getTime() <= end.getTime()
    );
  }, [history, appliedStartDate, appliedEndDate]);

  if (filteredHistory.length === 0) {
    return (
      <Box sx={{ width: '100%', height: 100, display: 'flex', alignItems: 'center', justifyContent: 'center', color: 'text.secondary', border: '1px dashed', borderColor: currentTheme.palette.grey[400], borderRadius: 2, p: 2 }}>
        <Typography variant="body2">No data available for selected date.</Typography>
      </Box>
    );
  }

  const chartData = filteredHistory.map(point => ({
    value: point.value,
    date: point.timestamp.toLocaleDateString('en-US', { year: 'numeric', month: 'short', day: 'numeric' }),
    fullDate: point.timestamp.toLocaleDateString('en-US', { year: 'numeric', month: 'short', day: 'numeric' }),
  }));

  return (
    <Box sx={{ width: '100%', height: 100 }}>
      <ResponsiveContainer width="100%" height="100%">
        <AreaChart data={chartData} margin={{ top: 5, right: 0, left: 0, bottom: 5 }}>
          <defs>
            <linearGradient id={`color${label}`} x1="0" y1="0" x2="0" y2="1">
              <stop offset="5%" stopColor={color} stopOpacity={0.8}/>
              <stop offset="95%" stopColor={currentTheme.palette.grey[300]} stopOpacity={0}/>
            </linearGradient>
          </defs>
          <RechartsTooltip
            labelFormatter={(labelValue, payload) => {
              if (payload && payload.length > 0 && payload[0].payload && payload[0].payload.fullDate) {
                return `Date: ${payload[0].payload.fullDate}`;
              }
              return `Date: ${labelValue}`;
            }}
            formatter={(value) => [`${value} ${unit}`, label]}
            contentStyle={{ backgroundColor: currentTheme.palette.background.paper, border: `1px solid ${currentTheme.palette.divider}` }}
            labelStyle={{ color: currentTheme.palette.text.primary }}
            itemStyle={{ color: currentTheme.palette.text.secondary }}
          />
          <Area type="monotone" dataKey="value" stroke={color} fillOpacity={1} fill={`url(#color${label})`} strokeWidth={2} dot={false} />
        </AreaChart>
      </ResponsiveContainer>
    </Box>
  );
};

interface ErrorRateTrendsProps {
  endpoints: Endpoint[];
  appliedStartDate: Date | null;
  appliedEndDate: Date | null;
  themeMode: 'light' | 'dark';
}

const ErrorRateTrends: React.FC<ErrorRateTrendsProps> = ({ endpoints, appliedStartDate, appliedEndDate, themeMode }) => {
  const currentTheme = themeMode === 'light' ? lightTheme : darkTheme;
  return (
    <Card>
      <CardContent>
        <Typography variant="h5" gutterBottom>
          Error Count Trends Over Time
        </Typography>
        <Box sx={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fit, minmax(300px, 1fr))', gap: 3 }}>
          {endpoints.map(endpoint => (
            <Card key={endpoint.id} variant="outlined" sx={{ borderRadius: 2 }}>
              <CardContent>
                <Typography variant="h6" gutterBottom sx={{ mb: 1 }}>
                  {endpoint.name}
                </Typography>
                <Typography variant="body2" color="textSecondary" sx={{ mb: 2 }}>
                  Server: {endpoint.serverName}
                </Typography>
                <MiniTrendGraph
                  history={endpoint.errorRateHistory.map(h => ({ ...h, timestamp: h.timestamp instanceof Date ? h.timestamp : new Date(h.timestamp) }))} // Convert timestamp string to Date
                  label="Errors"
                  unit="errors"
                  color={currentTheme.palette.error.main}
                  appliedStartDate={appliedStartDate}
                  appliedEndDate={appliedEndDate}
                  themeMode={themeMode}
                />
                <Typography variant="body2" component="span" sx={{ mt: 1 }}>
                  Current Errors: <Chip label={`${endpoint.errorRate} errors`} size="small" color={endpoint.errorRate > 10 ? 'error' : endpoint.errorRate > 3 ? 'warning' : 'success'} />
                </Typography>
              </CardContent>
            </Card>
          ))}
        </Box>
      </CardContent>
    </Card>
  );
};

interface LoginPageProps {
  onLoginSuccess: () => void;
  themeMode: 'light' | 'dark';
}

// Helper to convert hex to rgba
const hexToRgba = (hex: string, alpha: number) => {
  let r = 0, g = 0, b = 0;
  // Ensure hex is a string
  if (typeof hex !== 'string') {
    hex = String(hex);
  }
  // Handle #RRGGBB or #RGB
  if (hex.length === 7) {
    r = parseInt(hex.substring(1, 3), 16);
    g = parseInt(hex.substring(3, 5), 16);
    b = parseInt(hex.substring(5, 7), 16);
  } else if (hex.length === 4) {
    r = parseInt(hex[1] + hex[1], 16);
    g = parseInt(hex[2] + hex[2], 16);
    b = parseInt(hex[3] + hex[3], 16);
  }
  return `rgba(${r}, ${g}, ${b}, ${alpha})`;
};

const LoginPage: React.FC<LoginPageProps> = ({ onLoginSuccess, themeMode }) => {
  const [username, setUsername] = useState('');
  const [password, setPassword] = useState('');
  const [error, setError] = useState('');
  const currentTheme = useMemo(() => themeMode === 'light' ? lightTheme : darkTheme, [themeMode]);

  const handleLogin = (event: React.FormEvent) => {
    event.preventDefault();
    setError('');
    if (username === 'user' && password === 'password') {
      onLoginSuccess();
    } else {
      setError('Invalid username or password');
    }
  };

  return (
    <Container component="main" maxWidth="xs" sx={{
      height: '100vh',
      display: 'flex',
      flexDirection: 'column',
      justifyContent: 'center',
      alignItems: 'center',
      bgcolor: currentTheme.palette.background.default,
      p: 2,
    }}>
      <Card sx={{
        p: { xs: 3, sm: 4 },
        display: 'flex',
        flexDirection: 'column',
        alignItems: 'center',
        borderRadius: 3,
        boxShadow: 6,
        width: '100%',
        maxWidth: 400,
        bgcolor: hexToRgba(currentTheme.palette.primary.main, 0.3), // Transparent primary color
      }}>
        <Box sx={{ mb: 3, textAlign: 'center' }}>
          <Typography component="h1" variant="h4" sx={{ fontWeight: 'bold', color: currentTheme.palette.primary.contrastText }}>
            API Dashboard
          </Typography>
          <Typography variant="subtitle1" sx={{ color: currentTheme.palette.primary.contrastText }}>
            Sign in to continue
          </Typography>
        </Box>
        <Box component="form" onSubmit={handleLogin} noValidate sx={{ width: '100%' }}>
          <TextField
            margin="normal"
            required
            fullWidth
            id="username"
            label="Username"
            name="username"
            autoComplete="username"
            autoFocus
            value={username}
            onChange={(e) => setUsername(e.target.value)}
            sx={{ mb: 2 }}
          />
          <TextField
            margin="normal"
            required
            fullWidth
            name="password"
            label="Password"
            type="password"
            id="password"
            autoComplete="current-password"
            value={password}
            onChange={(e) => setPassword(e.target.value)}
            sx={{ mb: 3 }}
          />
          {error && (
            <Alert severity="error" sx={{ mt: 2, mb: 1, width: '100%' }}>
              {error}
            </Alert>
          )}
          <Button
            type="submit"
            fullWidth
            variant="contained"
            size="large"
            sx={{ mt: 3, mb: 2, borderRadius: 2 }}
          >
            Sign In
          </Button>
        </Box>
      </Card>
    </Container>
  );
};

// New FilteredDataDisplay Component
interface FilteredDataDisplayProps {
  bookRecords: BookResult[];
  loading: boolean;
  error: string | null;
  projectFilter: string;
  serverNameFilter: string; // Keep for display purposes
  appliedStartDate: Date | null; // Keep for display purposes
  appliedEndDate: Date | null; // Keep for display purposes
}

const FilteredDataDisplay: React.FC<FilteredDataDisplayProps> = ({ bookRecords, loading, error, projectFilter, serverNameFilter, appliedStartDate, appliedEndDate }) => {

  if (loading) {
    return (
      <Box sx={{ display: 'flex', justifyContent: 'center', alignItems: 'center', height: 200 }}>
        <CircularProgress />
        <Typography sx={{ ml: 2 }}>Loading filtered data...</Typography>
      </Box>
    );
  }

  if (error) {
    return (
      <Alert severity="error">
        <AlertTitle>Error</AlertTitle>
        {error}
      </Alert>
    );
  }

  return (
    <Card>
      <CardContent>
        <Typography variant="h5" gutterBottom>
          API Results for "{projectFilter || 'No Project Selected'}"
        </Typography>
        {bookRecords.length === 0 && projectFilter === '' ? (
          <Typography variant="body1" color="textSecondary">
            Please select a "Project" and click "Apply" to fetch data.
          </Typography>
        ) : bookRecords.length === 0 ? (
          <Typography variant="body1" color="textSecondary">
            No records found matching the selected filters.
          </Typography>
        ) : (
          <TableContainer component={Paper} sx={{ borderRadius: 2 }}>
            <Table stickyHeader aria-label="filtered data table">
              <TableHead>
                <TableRow>
                  <TableCell>Thumbnail</TableCell>
                  <TableCell>Title</TableCell>
                  <TableCell>Authors</TableCell>
                  <TableCell>Published Date</TableCell>
                  <TableCell>Description</TableCell>
                </TableRow>
              </TableHead>
              <TableBody>
                {bookRecords.map((record) => (
                  <TableRow key={record.id}>
                    <TableCell>
                      <img src={record.thumbnail} alt={record.title} style={{ width: 60, height: 80, borderRadius: 4 }} onError={(e) => { e.currentTarget.src = 'https://placehold.co/60x80/EEEEEE/AAAAAA?text=No+Image'; }} />
                    </TableCell>
                    <TableCell>{record.title}</TableCell>
                    <TableCell>{record.authors}</TableCell>
                    <TableCell>{record.publishedDate}</TableCell>
                    <TableCell>{record.description}</TableCell>
                  </TableRow>
                ))}
              </TableBody>
            </Table>
          </TableContainer>
        )}
      </CardContent>
    </Card>
  );
};


const App: React.FC = () => {
  const [endpoints, setEndpoints] = useState<Endpoint[]>([]);
  const [loading, setLoading] = useState<boolean>(true);
  const [initialFetchError, setInitialFetchError] = useState<string | null>(null);
  const [activeView, setActiveView] = useState<string>('table');
  const [startDateString, setStartDateString] = useState<string>('');
  const [endDateString, setEndDateString] = useState<string>('');
  const [appliedStartDate, setAppliedStartDate] = useState<Date | null>(null);
  const [appliedEndDate, setAppliedEndDate] = useState<Date | null>(null);
  const [serverNameFilter, setServerNameFilter] = useState<string>('');
  const [projectFilter, setProjectFilter] = useState<string>(''); // Initialized to empty string
  const [themeMode, setThemeMode] = useState<'light' | 'dark'>('dark');
  const [selectedTimeRange, setSelectedTimeRange] = useState<string>('');
  const [isLoggedIn, setIsLoggedIn] = useState<boolean>(false);
  const [showLogoutConfirm, setShowLogoutConfirm] = useState<boolean>(false);

  // State for FilteredDataDisplay's data
  const [filteredBookRecords, setFilteredBookRecords] = useState<BookResult[]>([]);
  const [filteredDataLoading, setFilteredDataLoading] = useState(false);
  const [filteredDataError, setFilteredDataError] = useState<string | null>(null);


  const [projectOptions, setProjectOptions] = useState<string[]>([]);
  const [serverOptions, setServerOptions] = useState<string[]>([]);


  const currentTheme = useMemo(() => themeMode === 'light' ? lightTheme : darkTheme, [themeMode]);

  // Use hardcoded options directly for uniqueServerNames and uniqueProjectNames
  const uniqueServerNames = useMemo(() => {
    return hardcodedServerNames.sort();
  }, []);

  const uniqueProjectNames = useMemo(() => {
    return hardcodedProjectNames.sort();
  }, []);

  // Effect to set initial endpoint data and filter options without API calls
  useEffect(() => {
    const initializeDashboardData = () => {
      setLoading(true);
      setInitialFetchError(null);

      const now = new Date();
      const oneHourAgo = new Date(now.getTime() - 60 * 60 * 1000);
      const twoHoursAgo = new Date(now.getTime() - 2 * 60 * 60 * 1000);

      // Simulate endpoints with hardcoded data (no external API calls here)
      const simulatedEndpoints: Endpoint[] = [
        {
          id: 'sim-ep-1', name: 'DTOCRUAT API', url: 'https://example.com/dtocruat', baselineLatency: 200,
          internalLatency: 150, externalLatency: 180,
          internalHealth: 'Green', externalHealth: 'Green',
          lastChecked: now.toISOString(),
          internalLatencyHistory: [
            { value: 140, timestamp: twoHoursAgo },
            { value: 160, timestamp: oneHourAgo },
            { value: 150, timestamp: now }
          ],
          externalLatencyHistory: [
            { value: 170, timestamp: twoHoursAgo },
            { value: 190, timestamp: oneHourAgo },
            { value: 180, timestamp: now }
          ],
          errorRate: 1, traffic: 1000,
          errorRateHistory: [
            { value: 0, timestamp: twoHoursAgo },
            { value: 2, timestamp: oneHourAgo },
            { value: 1, timestamp: now }
          ],
          serverName: '1', projectName: 'DTOCRUAT'
        },
        {
          id: 'sim-ep-2', name: 'DTOCRDEV API', url: 'https://example.com/dtocrdev', baselineLatency: 100,
          internalLatency: 90, externalLatency: 110, internalHealth: 'Green', externalHealth: 'Green',
          lastChecked: now.toISOString(),
          internalLatencyHistory: [
            { value: 85, timestamp: twoHoursAgo },
            { value: 95, timestamp: oneHourAgo },
            { value: 90, timestamp: now }
          ],
          externalLatencyHistory: [
            { value: 100, timestamp: twoHoursAgo },
            { value: 115, timestamp: oneHourAgo },
            { value: 110, timestamp: now }
          ],
          errorRate: 0, traffic: 500,
          errorRateHistory: [
            { value: 0, timestamp: twoHoursAgo },
            { value: 0, timestamp: oneHourAgo },
            { value: 0, timestamp: now }
          ],
          serverName: '2', projectName: 'DTOCRDEV'
        },
        {
          id: 'sim-ep-3', name: 'DTOCRSSDEV API', url: 'https://example.com/dtocrssdev', baselineLatency: 120,
          internalLatency: 110, externalLatency: 130, internalHealth: 'Yellow', externalHealth: 'Yellow',
          lastChecked: now.toISOString(),
          internalLatencyHistory: [
            { value: 100, timestamp: twoHoursAgo },
            { value: 120, timestamp: oneHourAgo },
            { value: 110, timestamp: now }
          ],
          externalLatencyHistory: [
            { value: 120, timestamp: twoHoursAgo },
            { value: 140, timestamp: oneHourAgo },
            { value: 130, timestamp: now }
          ],
          errorRate: 5, traffic: 700,
          errorRateHistory: [
            { value: 3, timestamp: twoHoursAgo },
            { value: 6, timestamp: oneHourAgo },
            { value: 5, timestamp: now }
          ],
          serverName: '3', projectName: 'DTOCRSSDEV'
        }
      ];
      setEndpoints(simulatedEndpoints);

      // Set hardcoded filter options
      setProjectOptions(hardcodedProjectNames);
      setServerOptions(hardcodedServerNames);

      setLoading(false);
    };

    initializeDashboardData();

  }, []);


  const totalEndpoints = endpoints.length;
  const healthyEndpoints = endpoints.filter(
    (e) => e.internalHealth === 'Green' && e.externalHealth === 'Green'
  ).length;
  const yellowEndpoints = endpoints.filter(
    (e) => e.internalHealth === 'Yellow' || e.externalHealth === 'Yellow'
  ).length;
  const redEndpoints = endpoints.filter(
    (e) => e.internalHealth === 'Red' || e.externalHealth === 'Red'
  ).length;

  const overallStatus = useMemo(() => {
    if (redEndpoints > 0) {
      return 'Critical';
    } else if (yellowEndpoints > 0) {
      return 'Degraded';
    } else if (healthyEndpoints === totalEndpoints && totalEndpoints > 0) {
      return 'Operational';
    } else {
      return 'Unknown';
    }
  }, [healthyEndpoints, yellowEndpoints, redEndpoints, totalEndpoints]);

  const getStatusProps = useCallback((health: 'Red' | 'Yellow' | 'Green' | 'Unknown') => {
    switch (health) {
      case 'Green':
        return { label: 'Healthy', color: 'success', icon: <CheckCircleOutlineIcon fontSize="small" /> };
      case 'Yellow':
        return { label: 'Degraded', color: 'warning', icon: <WarningAmberIcon fontSize="small" /> };
      case 'Red':
        return { label: 'Critical', color: 'error', icon: <ErrorOutlineIcon fontSize="small" /> };
      default:
        return { label: 'Unknown', color: 'default', icon: <HorizontalRuleIcon fontSize="small" /> };
    }
  }, []);

  const getTrendIcon = useCallback((trend: 'improving' | 'degrading' | 'stable' | 'unknown') => {
    switch (trend) {
      case 'improving':
        return <Tooltip title="Improving"><ArrowUpwardIcon color="success" fontSize="small" sx={{ ml: 0.5 }} /></Tooltip>;
      case 'degrading':
        return <Tooltip title="Degrading"><ArrowDownwardIcon color="error" fontSize="small" sx={{ ml: 0.5 }} /></Tooltip>;
      case 'stable':
        return <Tooltip title="Stable"><HorizontalRuleIcon color="action" fontSize="small" sx={{ ml: 0.5 }} /></Tooltip>;
      default:
        return null;
    }
  }, []);

  const handleApplyFilter = async () => { // Made async to await data fetch
    console.log('Apply button clicked. Current filters:', { startDateString, endDateString, selectedTimeRange, projectFilter, serverNameFilter });
    const now = new Date();
    let newAppliedStartDate: Date | null = null;
    let newAppliedEndDate: Date | null = null;
    let timespanToSend: string | null = null;

    if (selectedTimeRange) {
      timespanToSend = selectedTimeRange === '1min' ? '1 Minute' :
                       selectedTimeRange === '3min' ? '3 Minutes' :
                       selectedTimeRange === '5min' ? '5 Minutes' :
                       selectedTimeRange === '1hour' ? '1 Hour' :
                       selectedTimeRange === '3hours' ? '3 Hours' :
                       selectedTimeRange === '1day' ? '24 Hours' :
                       selectedTimeRange === '1week' ? '7 Days' :
                       selectedTimeRange === '1month' ? '30 Days' : null;
      // If a time range is selected, fromDate and toDate should be null in the payload
      newAppliedStartDate = null;
      newAppliedEndDate = null;
    } else {
      if (startDateString) {
        newAppliedStartDate = new Date(startDateString);
        newAppliedStartDate.setHours(0, 0, 0, 0);
      }
      if (endDateString) {
        newAppliedEndDate = new Date(endDateString);
        newAppliedEndDate.setHours(23, 59, 59, 999);
      }
      // If specific dates are selected, timespan should be null in the payload
      timespanToSend = null;
    }

    // Default to "24 Hours" if no specific dates or time range are set
    if (!timespanToSend && !newAppliedStartDate && !newAppliedEndDate) {
      timespanToSend = "24 Hours";
    }


    setAppliedStartDate(newAppliedStartDate);
    setAppliedEndDate(newAppliedEndDate);

    // --- Start: Moved data fetching logic here ---
    setFilteredDataLoading(true);
    setFilteredDataError(null);
    setFilteredBookRecords([]); // Clear previous data immediately on apply click

    try {
      const data = await fetchFilteredDataFromAPI({
        project: projectFilter,
        server: serverNameFilter, // This is not sent to the new API, but kept for UI state
        startDate: newAppliedStartDate,
        endDate: newAppliedEndDate,
        timespan: timespanToSend, // Pass the derived timespan
      });

      // Apply client-side date filtering if specific dates were chosen (and API doesn't filter)
      const filteredByDate = data.filter(book => {
        // If timespan was used, or no dates were specified, skip client-side date filter
        if (timespanToSend || (!newAppliedStartDate && !newAppliedEndDate)) return true;

        let bookPublishedDate: Date;
        if (book.publishedDate.length === 4) {
          bookPublishedDate = new Date(parseInt(book.publishedDate), 0, 1);
        } else if (book.publishedDate.length === 7 && book.publishedDate.includes('-')) {
          bookPublishedDate = new Date(book.publishedDate + '-01');
        } else {
          bookPublishedDate = new Date(book.publishedDate);
        }

        if (isNaN(bookPublishedDate.getTime())) {
          console.warn(`Could not parse publishedDate: ${book.publishedDate} for book: ${book.title}. Skipping date filter for this book.`);
          return true;
        }

        const startOfDayAppliedStartDate = new Date(newAppliedStartDate!);
        startOfDayAppliedStartDate.setHours(0, 0, 0, 0);
        const endOfDayAppliedEndDate = new Date(newAppliedEndDate!);
        endOfDayAppliedEndDate.setHours(23, 59, 59, 999);

        return bookPublishedDate >= startOfDayAppliedStartDate && bookPublishedDate <= endOfDayAppliedEndDate;
      });

      setFilteredBookRecords(filteredByDate);
    } catch (error) {
      setFilteredDataError(`Failed to fetch data: ${(error as Error).message}`);
    } finally {
      setFilteredDataLoading(false);
    }
    // --- End: Moved data fetching logic here ---
  };

  const handleClearFilters = () => {
    setStartDateString('');
    setEndDateString('');
    setAppliedStartDate(null);
    setAppliedEndDate(null);
    setServerNameFilter('');
    setProjectFilter(''); // Clear project filter
    setSelectedTimeRange('');
    setFilteredBookRecords([]); // Clear displayed data
    setFilteredDataError(null);
    setFilteredDataLoading(false);
  };

  const filteredEndpointsByProject = useMemo(() => {
    if (!projectFilter) {
      return endpoints;
    }
    return endpoints.filter(endpoint => endpoint.projectName === projectFilter);
  }, [endpoints, projectFilter]);

  const filteredEndpointsByServer = useMemo(() => {
    if (!serverNameFilter) {
      return filteredEndpointsByProject;
    }
    return filteredEndpointsByProject.filter(endpoint => endpoint.serverName === serverNameFilter);
  }, [filteredEndpointsByProject, serverNameFilter]);

  const displayEndpoints = useMemo(() => {
    let currentEndpoints = filteredEndpointsByServer;

    if (appliedStartDate && appliedEndDate) {
      currentEndpoints = currentEndpoints.filter(endpoint =>
        endpoint.lastChecked &&
        new Date(endpoint.lastChecked).getTime() >= appliedStartDate.getTime() &&
        new Date(endpoint.lastChecked).getTime() <= appliedEndDate.getTime()
      );
    }
    return currentEndpoints;
  }, [filteredEndpointsByServer, appliedStartDate, appliedEndDate]);


  const toggleTheme = () => {
    setThemeMode((prevMode) => (prevMode === 'light' ? 'dark' : 'light'));
  };

  const handleLoginSuccess = () => {
    setIsLoggedIn(true);
  };

  const handleLogoutRequest = () => {
    setShowLogoutConfirm(true);
  };

  const handleConfirmLogout = () => {
    setIsLoggedIn(false);
    setActiveView('table');
    handleClearFilters();
    setShowLogoutConfirm(false);
  };

  const handleCancelLogout = () => {
    setShowLogoutConfirm(false);
  };

  if (loading) {
    return (
      <ThemeProvider theme={currentTheme}>
        <CssBaseline />
        <Box sx={{ display: 'flex', justifyContent: 'center', alignItems: 'center', height: '100vh', flexDirection: 'column' }}>
          <CircularProgress size={60} sx={{ mb: 2 }} />
          <Typography variant="h6" color="textSecondary">Loading API Status...</Typography>
        </Box>
      </ThemeProvider>
    );
  }

  if (!isLoggedIn) {
    return (
      <ThemeProvider theme={currentTheme}>
        <CssBaseline />
        <LoginPage onLoginSuccess={handleLoginSuccess} themeMode={themeMode} />
      </ThemeProvider>
    );
  }

  return (
    <ThemeProvider theme={currentTheme}>
      <CssBaseline />
      <Box sx={{ display: 'flex', minHeight: '100vh', bgcolor: 'background.default' }}>
        <SidebarNav onSelectView={setActiveView} activeView={activeView} themeMode={themeMode} onLogoutRequest={handleLogoutRequest} />
        <Container maxWidth="xl" sx={{ flexGrow: 1, p: 3, overflowY: 'auto' }}>
          <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 4 }}>
            <Typography variant="h4" component="h1" gutterBottom sx={{ fontWeight: 'bold', color: currentTheme.palette.text.primary }}>
              API Monitoring Dashboard
            </Typography>
            <IconButton onClick={toggleTheme} color="inherit">
              {themeMode === 'dark' ? <Brightness7Icon /> : <Brightness4Icon />}
            </IconButton>
          </Box>

          {initialFetchError && (
            <Alert severity="error" sx={{ mb: 4, width: '100%' }}>
              <AlertTitle>API Connection Error</AlertTitle>
              {initialFetchError}
            </Alert>
          )}

          {/* Conditional rendering of filter options */}
          {(activeView === 'table' || activeView === 'summary' || activeView === 'error_trends' || activeView === 'filtered_data') && (
            <Box sx={{ display: 'flex', gap: 1, mb: 4, alignItems: 'center', flexWrap: 'wrap' }}>
              {/* Project Dropdown */}
              <FormControl sx={{ minWidth: 120 }}>
                <InputLabel id="project-select-label">Project</InputLabel>
                <Select
                  labelId="project-select-label"
                  id="project-select"
                  value={projectFilter}
                  label="Project"
                  onChange={(e) => {
                    setProjectFilter(e.target.value as string);
                    setServerNameFilter('');
                  }}
                  sx={{ borderRadius: 2 }}
                >
                  <MenuItem value="">
                    <em>Select Project</em>
                  </MenuItem>
                  {uniqueProjectNames.map(name => (
                    <MenuItem key={name} value={name}>{name}</MenuItem>
                  ))}
                </Select>
              </FormControl>

              {/* Server Dropdown */}
              <FormControl sx={{ minWidth: 120 }}>
                <InputLabel id="server-name-select-label">Server</InputLabel>
                <Select
                  labelId="server-name-select-label"
                  id="server-name-select"
                  value={serverNameFilter}
                  label="Server"
                  onChange={(e) => setServerNameFilter(e.target.value as string)}
                  sx={{ borderRadius: 2 }}
                >
                  <MenuItem value="">
                    <em>Select Server</em>
                  </MenuItem>
                  {uniqueServerNames.map(name => (
                    <MenuItem key={name} value={name}>{name}</MenuItem>
                  ))}
                </Select>
              </FormControl>

              {/* Time Range Dropdown */}
              <FormControl sx={{ minWidth: 130 }}>
                <InputLabel id="time-range-select-label">Time Range</InputLabel>
                <Select
                  labelId="time-range-select-label"
                  id="time-range-select"
                  value={selectedTimeRange}
                  label="Time Range"
                  onChange={(e) => { setSelectedTimeRange(e.target.value as string); }}
                  sx={{ borderRadius: 2 }}
                >
                  <MenuItem value="">
                    <em>None</em>
                  </MenuItem>
                  <MenuItem value="1min">Last 1 min</MenuItem>
                  <MenuItem value="3min">Last 3 min</MenuItem>
                  <MenuItem value="5min">Last 5 min</MenuItem>
                  <MenuItem value="1hour">Last 1 hour</MenuItem>
                  <MenuItem value="3hours">Last 3 hours</MenuItem>
                  <MenuItem value="1day">Last 1 Day</MenuItem>
                  <MenuItem value="1week">Last 1 Week</MenuItem>
                  <MenuItem value="1month">Last 1 Month</MenuItem>
                </Select>
              </FormControl>

              {/* Start Date */}
              <TextField
                label="From Date"
                type="date"
                value={startDateString}
                onChange={(e) => { setStartDateString(e.target.value); setSelectedTimeRange(''); }}
                InputLabelProps={{ shrink: true }}
                inputProps={{ id: 'startDateInput' }}
              />
              {/* End Date */}
              <TextField
                label="To Date"
                type="date"
                value={endDateString}
                onChange={(e) => { setEndDateString(e.target.value); setSelectedTimeRange(''); }}
                InputLabelProps={{ shrink: true }}
                inputProps={{ id: 'endDateInput' }}
              />
              <Button
                variant="contained"
                onClick={handleApplyFilter}
                sx={{ height: '40px', px: 2, borderRadius: 2 }}
              >
                Apply
              </Button>
              <Button
                variant="outlined"
                onClick={handleClearFilters}
                sx={{ height: '40px', px: 2, borderRadius: 2 }}
              >
                Clear
              </Button>
            </Box>
          )}

          {activeView === 'summary' && (
            <OverallSummaryStatus
              totalEndpoints={displayEndpoints.length}
              healthyEndpoints={displayEndpoints.filter(
                (e) => e.internalHealth === 'Green' && e.externalHealth === 'Green'
              ).length}
              yellowEndpoints={displayEndpoints.filter(
                (e) => e.internalHealth === 'Yellow' || e.externalHealth === 'Yellow'
              ).length}
              redEndpoints={displayEndpoints.filter(
                (e) => e.internalHealth === 'Red' || e.externalHealth === 'Red'
              ).length}
              overallStatus={overallStatus}
            />
          )}

          {activeView === 'table' && (
            <IndividualEndpointStatusTable
              endpoints={displayEndpoints}
              getStatusProps={getStatusProps}
              getTrendIcon={getTrendIcon}
              appliedStartDate={appliedStartDate}
              appliedEndDate={appliedEndDate}
              themeMode={themeMode}
            />
          )}

          {activeView === 'error_trends' && (
            <ErrorRateTrends
              endpoints={displayEndpoints}
              appliedStartDate={appliedStartDate}
              appliedEndDate={appliedEndDate}
              themeMode={themeMode}
            />
          )}

          {activeView === 'filtered_data' && (
            <FilteredDataDisplay
              bookRecords={filteredBookRecords}
              loading={filteredDataLoading}
              error={filteredDataError}
              projectFilter={projectFilter}
              serverNameFilter={serverNameFilter}
              appliedStartDate={appliedStartDate}
              appliedEndDate={appliedEndDate}
            />
          )}

          {activeView === 'notifications' && <NotificationAlerting />}
          {activeView === 'selfHealing' && <AutomatedSelfHealingActions />}
          {activeView === 'user_profile' && <UserProfileTable />}
        </Container>
      </Box>

      {/* Logout Confirmation Dialog */}
      <Dialog
        open={showLogoutConfirm}
        onClose={handleCancelLogout}
        aria-labelledby="logout-dialog-title"
        aria-describedby="logout-dialog-description"
      >
        <DialogTitle id="logout-dialog-title">{"Confirm Logout"}</DialogTitle>
        <DialogContent>
          <Typography id="logout-dialog-description">
            Are you sure you want to log out?
          </Typography>
        </DialogContent>
        <DialogActions>
          <Button onClick={handleCancelLogout} color="primary">
            Cancel
          </Button>
          <Button onClick={handleConfirmLogout} color="primary" autoFocus>
            Logout
          </Button>
        </DialogActions>
      </Dialog>
    </ThemeProvider>
  );
};

export default App;

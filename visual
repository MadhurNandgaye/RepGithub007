import React, { useState, useEffect, useRef, useMemo, useCallback } from 'react';
import {
  Container,
  Typography,
  Box,
  Card,
  CardContent,
  Table,
  TableBody,
  TableCell,
  TableContainer,
  TableHead,
  TableRow,
  Paper,
  Chip,
  Alert,
  AlertTitle,
  CssBaseline,
  ThemeProvider,
  createTheme,
  CircularProgress,
  Tooltip,
  Button,
  List,
  ListItem,
  ListItemButton,
  ListItemIcon,
  ListItemText,
  TextField,
  Select,
  MenuItem,
  FormControl,
  InputLabel,
  IconButton,
} from '@mui/material';
import CheckCircleOutlineIcon from '@mui/icons-material/CheckCircleOutline';
import WarningAmberIcon from '@mui/icons-material/WarningAmber';
import ErrorOutlineIcon from '@mui/icons-material/ErrorOutline';
import ArrowUpwardIcon from '@mui/icons-material/ArrowUpward';
import ArrowDownwardIcon from '@mui/icons-material/ArrowDownward';
import HorizontalRuleIcon from '@mui/icons-material/HorizontalRule';
import AnalyticsIcon from '@mui/icons-material/Analytics';
import BugReportIcon from '@mui/icons-material/BugReport';
import MemoryIcon from '@mui/icons-material/Memory';
import DeveloperBoardIcon from '@mui/icons-material/DeveloperBoard';
import DashboardIcon from '@mui/icons-material/Dashboard';
import TableChartIcon from '@mui/icons-material/TableChart';
import GridOnIcon from '@mui/icons-material/GridOn';
import NotificationsIcon from '@mui/icons-material/Notifications';
import AutoFixHighIcon from '@mui/icons-material/AutoFixHigh';
import Brightness4Icon from '@mui/icons-material/Brightness4';
import Brightness7Icon from '@mui/icons-material/Brightness7';


import {
  AreaChart,
  Area,
  ResponsiveContainer,
  Tooltip as RechartsTooltip,
} from 'recharts';
import { blueGrey } from '@mui/material/colors';

// Define the light theme
const lightTheme = createTheme({
  typography: {
    fontFamily: 'Inter, sans-serif',
    h4: {
      fontWeight: 700,
      marginBottom: '1rem',
    },
    h5: {
      fontWeight: 600,
      marginBottom: '0.8rem',
    },
    h6: {
      fontWeight: 500,
    },
  },
  palette: {
    mode: 'light',
    primary: {
      main: '#1976d2',
    },
    secondary: {
      main: '#dc004e',
    },
    success: {
      main: '#4caf50',
    },
    warning: {
      main: '#ff9800',
    },
    error: {
      main: '#f44336',
    },
    background: {
      default: '#f4f6f8',
      paper: '#ffffff',
    },
    grey: {
      300: '#e0e0e0',
      500: '#9e9e9e',
    },
  },
  components: {
    MuiCard: {
      styleOverrides: {
        root: {
          borderRadius: 12,
          boxShadow: '0 4px 20px rgba(0,0,0,0.05)',
        },
      },
    },
    MuiChip: {
      styleOverrides: {
        root: {
          borderRadius: 8,
          fontWeight: 600,
          minWidth: 80,
          justifyContent: 'center',
        },
      },
    },
    MuiTableCell: {
      styleOverrides: {
        head: {
          fontWeight: 600,
          backgroundColor: '#e0e0e0',
        },
      },
    },
  },
});

// Define the dark theme
const darkTheme = createTheme({
  typography: {
    fontFamily: 'Inter, sans-serif',
    h4: {
      fontWeight: 700,
      marginBottom: '1rem',
    },
    h5: {
      fontWeight: 600,
      marginBottom: '0.8rem',
    },
    h6: {
      fontWeight: 500,
    },
  },
  palette: {
    mode: 'dark',
    primary: {
      main: '#90caf9',
    },
    secondary: {
      main: '#f48fb1',
    },
    success: {
      main: '#81c784',
    },
    warning: {
      main: '#ffb74d',
    },
    error: {
      main: '#e57373',
    },
    background: {
      default: '#121212',
      paper: '#1e1e1e',
    },
    grey: {
      300: '#424242',
      500: '#bdbdbd',
    },
  },
  components: {
    MuiCard: {
      styleOverrides: {
        root: {
          borderRadius: 12,
          boxShadow: '0 4px 20px rgba(0,0,0,0.3)',
        },
      },
    },
    MuiChip: {
      styleOverrides: {
        root: {
          borderRadius: 8,
          fontWeight: 600,
          minWidth: 80,
          justifyContent: 'center',
        },
      },
    },
    MuiTableCell: {
      styleOverrides: {
        head: {
          fontWeight: 600,
          backgroundColor: '#333333',
        },
      },
    },
  },
});

// Interface for a single history data point with timestamp
interface HistoryDataPoint {
  value: number;
  timestamp: Date;
}

// Interface for a single API endpoint
interface Endpoint {
  id: string;
  name: string;
  url: string;
  baselineLatency: number;
  internalLatency: number | null;
  externalLatency: number | null;
  internalHealth: 'Red' | 'Yellow' | 'Green' | 'Unknown';
  externalHealth: 'Red' | 'Yellow' | 'Green' | 'Unknown';
  lastChecked: Date | null; // This will be a fixed historical date for filtering the table rows
  internalLatencyHistory: HistoryDataPoint[];
  externalLatencyHistory: HistoryDataPoint[];
  errorRate: number;
  traffic: number;
  errorRateHistory: HistoryDataPoint[];
  serverName: string;
}

const MAX_HISTORY_POINTS = 60; // Number of data points to keep in history for trends
const HISTORY_SPAN_DAYS = 7; // Number of days the generated history should span for initial data

// Helper function to generate initial dummy history data with timestamps
const generateDummyHistory = (
  length: number, // Number of data points
  baseValue: number,
  amplitude: number,
  frequency: number,
  randomness: number,
  referenceDate: Date // The date around which history should be generated
): HistoryDataPoint[] => {
  const history: HistoryDataPoint[] = [];
  // Distribute 'length' history points backwards from the 'referenceDate' over the last HISTORY_SPAN_DAYS
  const historySpanMs = HISTORY_SPAN_DAYS * 24 * 60 * 60 * 1000;
  const startTime = referenceDate.getTime() - historySpanMs;

  for (let i = 0; i < length; i++) {
    const value = Math.max(0, baseValue + Math.sin(i * frequency) * amplitude + Math.random() * randomness);
    const timestamp = new Date(startTime + (i * (historySpanMs / length)));
    history.push({ value: parseFloat(value.toFixed(1)), timestamp });
  }
  return history;
};

// Generate initial endpoints across multiple servers
const generateInitialEndpoints = (): Endpoint[] => {
  const endpoints: Endpoint[] = [];
  const serverNames = ['Server Alpha', 'Server Beta', 'Server Gamma', 'Server Delta', 'Server Epsilon'];
  const httpMethods = ['GET', 'POST', 'PUT', 'DELETE'];
  const apiPaths = [
    '/users/{id}', '/products/search', '/orders', '/auth/login', '/data/analytics',
    '/swagger/swagger-ui.css', '/swagger/swagger-ui-bundle.js', '/api/v1/health',
    '/payments/process', '/notifications/send', '/dtocr/legalparser',
    '/authentication/getbeartoken', '/reports/daily', '/inventory/update',
    '/customers/{id}/profile', '/billing/invoice', '/support/ticket',
    '/metrics/cpu', '/logs/errors', '/admin/settings',
    '/search/documents', '/files/upload', '/streams/live',
    '/analytics/events', '/dashboard/summary', '/config/get',
    '/status/check', '/users/register', '/products/add',
    '/orders/track', '/auth/logout', '/data/export',
    '/swagger/index.html', '/api/v2/status', '/payments/refund',
    '/notifications/read', '/dtocr/legalvalidator', '/authentication/refresh',
    '/reports/monthly', '/inventory/lookup', '/customers/new',
    '/billing/statement', '/support/faq', '/metrics/memory',
    '/logs/access', '/admin/users', '/search/articles',
    '/files/download', '/streams/archive', '/analytics/users',
    '/dashboard/details', '/config/set', '/status/ping'
  ];

  const totalEndpointsToGenerate = 50; // Generate a fixed, larger number of endpoints

  for (let i = 0; i < totalEndpointsToGenerate; i++) {
    const baseline = Math.floor(Math.random() * (250 - 50 + 1)) + 50;
    const randomMethod = httpMethods[Math.floor(Math.random() * httpMethods.length)];
    const randomPath = apiPaths[Math.floor(Math.random() * apiPaths.length)];
    const randomServerName = serverNames[Math.floor(Math.random() * serverNames.length)];
    
    const endpointName = `${randomMethod} ${randomPath}`;

    // For lastChecked, pick a random date within the last 60 days (for table filtering)
    const now = new Date();
    const randomDaysAgo = Math.floor(Math.random() * 60); // 0 to 59 days ago
    const initialLastChecked = new Date(now.getTime() - randomDaysAgo * 24 * 60 * 60 * 1000);
    initialLastChecked.setHours(Math.floor(Math.random() * 24), Math.floor(Math.random() * 60), Math.floor(Math.random() * 60), 0);

    endpoints.push({
      id: String(i + 1), // Use i+1 for unique IDs
      name: endpointName,
      url: `https://api.example.com/${randomServerName.toLowerCase().replace(' ', '-')}${randomPath}`,
      baselineLatency: baseline,
      internalLatency: null,
      externalLatency: null,
      internalHealth: 'Unknown',
      externalHealth: 'Unknown',
      lastChecked: initialLastChecked, // This will be the static last checked date for filtering the table rows
      internalLatencyHistory: generateDummyHistory(MAX_HISTORY_POINTS, baseline, baseline * 0.2, 0.5, 10, initialLastChecked),
      externalLatencyHistory: generateDummyHistory(MAX_HISTORY_POINTS, baseline * 1.2, baseline * 0.25, 0.5, 10, initialLastChecked),
      errorRate: 0,
      traffic: 0,
      errorRateHistory: generateDummyHistory(MAX_HISTORY_POINTS, 1, 1, 0.3, 0.5, initialLastChecked),
      serverName: randomServerName,
    });
  }
  return endpoints;
};

const initialEndpoints: Endpoint[] = generateInitialEndpoints();


// Helper function to simulate API call and determine health status based on latency
const simulateApiCall = (baseline: number): { latency: number; health: 'Red' | 'Yellow' | 'Green'; errorRate: number; traffic: number } => {
  const randomFactor = Math.random();
  let latency: number;
  let health: 'Red' | 'Yellow' | 'Green';
  let errorRate: number;
  let traffic: number;

  if (randomFactor < 0.7) {
    latency = baseline * (0.8 + Math.random() * 0.2);
    health = 'Green';
    errorRate = Math.round(Math.random() * 2);
    traffic = Math.round(50 + Math.random() * 100);
  } else if (randomFactor < 0.9) {
    latency = baseline * (1.0 + Math.random() * 1.0);
    health = 'Yellow';
    errorRate = Math.round(3 + Math.random() * 7);
    traffic = Math.round(100 + Math.random() * 200);
  } else {
    latency = baseline * (2.0 + Math.random() * 2.0);
    health = 'Red';
    errorRate = Math.round(10 + Math.random() * 20);
    traffic = Math.round(20 + Math.random() * 50);
  }

  latency += Math.random() * 20;

  return { latency: Math.round(latency), health, errorRate, traffic };
};

// Helper function to determine trend based on recent history
const getTrend = (history: HistoryDataPoint[]): 'improving' | 'degrading' | 'stable' | 'unknown' => {
  if (history.length < 2) {
    return 'unknown';
  }

  const current = history[history.length - 1].value;
  const prev = history[history.length - 2].value;

  if (current < prev * 0.9) {
    return 'improving';
  } else if (current > prev * 1.1) {
    return 'degrading';
  } else {
    return 'stable';
  }
};

// Interface for the LatencyBar component props
interface LatencyBarProps {
  currentLatency: number;
  baselineLatency: number;
  health: 'Red' | 'Yellow' | 'Green' | 'Unknown';
  themeMode: 'light' | 'dark';
}

// LatencyBar component to visually represent latency against baseline
const LatencyBar: React.FC<LatencyBarProps> = ({ currentLatency, baselineLatency, health, themeMode }) => {
  const currentTheme = themeMode === 'light' ? lightTheme : darkTheme;
  const visualBaselineWidth = 60;
  const ratio = currentLatency / baselineLatency;
  let barWidth = visualBaselineWidth * ratio;
  const maxVisualWidth = visualBaselineWidth * 2.0;
  if (barWidth > maxVisualWidth) {
    barWidth = maxVisualWidth;
  }

  let barColor: string;
  switch (health) {
    case 'Green':
      barColor = currentTheme.palette.success.main;
      break;
    case 'Yellow':
      barColor = currentTheme.palette.warning.main;
      break;
    case 'Red':
      barColor = currentTheme.palette.error.main;
      break;
    default:
      barColor = currentTheme.palette.grey[500];
      break;
  }

  return (
    <Tooltip title={`Current: ${currentLatency}ms (Baseline: ${baselineLatency}ms)`}>
      <Box
        sx={{
          width: visualBaselineWidth,
          height: 8,
          backgroundColor: currentTheme.palette.grey[300],
          borderRadius: 4,
          overflow: 'hidden',
          position: 'relative',
          mr: 1,
        }}
      >
        <Box
          sx={{
            width: `${barWidth}px`,
            height: '100%',
            backgroundColor: barColor,
            borderRadius: 4,
            transition: 'width 0.3s ease-in-out, background-color 0.3s ease-in-out',
          }}
        />
      </Box>
    </Tooltip>
  );
};

// Interface for the OverallApiStatusGrid component props
interface OverallApiStatusGridProps {
  endpoints: Endpoint[];
  appliedStartDate: Date | null;
  appliedEndDate: Date | null;
  themeMode: 'light' | 'dark';
}

// OverallApiStatusGrid component to visualize overall API health, error rate, traffic
const OverallApiStatusGrid: React.FC<OverallApiStatusGridProps> = ({ endpoints, appliedStartDate, appliedEndDate, themeMode }) => {
  const currentTheme = themeMode === 'light' ? lightTheme : darkTheme;
  // Helper to determine the single overall health for an endpoint
  const getOverallHealth = (endpoint: Endpoint): 'Red' | 'Yellow' | 'Green' | 'Unknown' => {
    if (endpoint.internalHealth === 'Red' || endpoint.externalHealth === 'Red') {
      return 'Red';
    } else if (endpoint.internalHealth === 'Yellow' || endpoint.externalHealth === 'Yellow') {
      return 'Yellow';
    } else if (endpoint.internalHealth === 'Green' && endpoint.externalHealth === 'Green') {
      return 'Green';
    }
    return 'Unknown';
  };

  // Helper to get error rate color
  const getErrorRateColor = (errorRate: number) => {
    if (errorRate > 10) return currentTheme.palette.error.main;
    if (errorRate > 3) return currentTheme.palette.warning.main;
    return currentTheme.palette.success.main;
  };

  // Helper to get traffic indicator color (can be adapted for more complex logic)
  const getTrafficColor = (traffic: number) => {
    if (traffic > 200) return currentTheme.palette.primary.main;
    if (traffic < 50) return currentTheme.palette.warning.main;
    return currentTheme.palette.success.main;
  };

  // Helper to calculate average from history based on date range
  const calculateAverage = (history: HistoryDataPoint[], startDate: Date | null, endDate: Date | null) => {
    let filteredHistory = history;
    if (startDate && endDate) {
      filteredHistory = history.filter(point =>
        point.timestamp.getTime() >= startDate.getTime() &&
        point.timestamp.getTime() <= endDate.getTime()
      );
    }

    if (filteredHistory.length === 0) return 'N/A';
    const sum = filteredHistory.reduce((acc, val) => acc + val.value, 0);
    return (sum / filteredHistory.length).toFixed(1);
  };

  return (
    <Card>
      <CardContent>
        <Typography variant="h5" gutterBottom>
          API Health Overview (Error Rate, Traffic)
        </Typography>
        <TableContainer component={Paper} sx={{ borderRadius: 2 }}>
          <Table aria-label="api status grid table">
            <TableHead>
              <TableRow><TableCell>No.</TableCell><TableCell>Server Name</TableCell><TableCell>Endpoint Name</TableCell><TableCell align="center">Overall Health</TableCell><TableCell align="right">Current Error Rate (%)</TableCell><TableCell align="right">Avg Error Rate (%)</TableCell><TableCell align="right">Traffic (RPS)</TableCell></TableRow>
            </TableHead>
            <TableBody>
              {endpoints.map((endpoint, index) => ( // Added index here
                <TableRow key={endpoint.id}><TableCell>{index + 1}</TableCell><TableCell>{endpoint.serverName}</TableCell><TableCell component="th" scope="row">{endpoint.name}</TableCell><TableCell align="center"><Chip label={getOverallHealth(endpoint)} color={getOverallHealth(endpoint) === 'Green' ? 'success' : getOverallHealth(endpoint) === 'Yellow' ? 'warning' : getOverallHealth(endpoint) === 'Red' ? 'error' : 'default'} sx={{ width: 100 }} /></TableCell><TableCell align="right" sx={{ color: getErrorRateColor(endpoint.errorRate), fontWeight: 500 }}>{endpoint.errorRate}%</TableCell><TableCell align="right">{calculateAverage(endpoint.errorRateHistory, appliedStartDate, appliedEndDate)}</TableCell><TableCell align="right" sx={{ color: getTrafficColor(endpoint.traffic), fontWeight: 500 }}>{endpoint.traffic}</TableCell></TableRow>
              ))}
            </TableBody>
          </Table>
        </TableContainer>
      </CardContent>
    </Card>
  );
};

// New components for each section
const OverallSummaryStatus: React.FC<{ totalEndpoints: number; healthyEndpoints: number; yellowEndpoints: number; redEndpoints: number; overallStatus: string }> = ({ totalEndpoints, healthyEndpoints, yellowEndpoints, redEndpoints, overallStatus }) => (
  <Card>
    <CardContent>
      <Typography variant="h5" gutterBottom>
        Overall System Status
      </Typography>
      <Box sx={{ display: 'flex', alignItems: 'center', gap: 2, mb: 2 }}>
        <Chip
          label={overallStatus}
          color={
            overallStatus === 'Operational'
              ? 'success'
              : overallStatus === 'Degraded'
              ? 'warning'
              : 'error'
          }
          sx={{ fontSize: '1rem', padding: '0.5rem 1rem', height: 'auto' }}
        />
        <Typography variant="body1">
          {overallStatus === 'Operational' && 'All monitored endpoints are currently healthy and performing within expected baselines.'}
          {overallStatus === 'Degraded' && `Some endpoints (${yellowEndpoints} yellow) are experiencing degraded performance. Further investigation may be needed.`}
          {overallStatus === 'Critical' && `Critical issues detected! ${redEndpoints} endpoints are experiencing severe problems. Immediate attention required!`}
        </Typography>
      </Box>
      <Typography variant="body2" color="textSecondary">
        Total Endpoints Monitored: {totalEndpoints} | Healthy: {healthyEndpoints} | Degraded: {yellowEndpoints} | Critical: {redEndpoints}
      </Typography>
    </CardContent>
  </Card>
);

const IndividualEndpointStatusTable: React.FC<{ endpoints: Endpoint[]; getStatusProps: Function; getTrendIcon: Function; appliedStartDate: Date | null; appliedEndDate: Date | null; themeMode: 'light' | 'dark' }> = ({ endpoints, getStatusProps, getTrendIcon, appliedStartDate, appliedEndDate, themeMode }) => {
  // Filter endpoints based on the last checked date within the selected range
  const filteredEndpoints = useMemo(() => {
    if (!appliedStartDate || !appliedEndDate) {
      return endpoints;
    }
    const start = appliedStartDate;
    const end = appliedEndDate;

    return endpoints.filter(endpoint =>
      endpoint.lastChecked &&
      endpoint.lastChecked.getTime() >= start.getTime() &&
      endpoint.lastChecked.getTime() <= end.getTime()
    );
  }, [endpoints, appliedStartDate, appliedEndDate]);

  return (
    <Card>
      <CardContent>
        <Typography variant="h5" gutterBottom>
          Individual Endpoint Health Status
        </Typography>
        <TableContainer component={Paper} sx={{ borderRadius: 2 }}>
          <Table stickyHeader aria-label="endpoint health table">
            <TableHead>
              <TableRow><TableCell>No.</TableCell><TableCell sx={{ minWidth: '150px' }}>Endpoint Name</TableCell><TableCell sx={{ minWidth: '200px' }}>URL</TableCell><TableCell align="center">Internal Health</TableCell><TableCell align="center">External Health</TableCell><TableCell align="right" sx={{ minWidth: '60px' }}>Internal Latency (ms)</TableCell><TableCell align="right" sx={{ minWidth: '120px' }}>External Latency (ms)</TableCell><TableCell align="right" sx={{ minWidth: '80px' }}>Baseline (ms)</TableCell><TableCell align="center" sx={{ minWidth: '100px' }}>Last Checked</TableCell></TableRow>
            </TableHead>
            <TableBody>
              {filteredEndpoints.map((endpoint, index) => ( // Added index here
                <TableRow key={endpoint.id}><TableCell>{index + 1}</TableCell><TableCell component="th" scope="row">{endpoint.name}</TableCell><TableCell>{endpoint.url}</TableCell><TableCell align="center"><Chip {...getStatusProps(endpoint.internalHealth)} size="small" sx={{ width: 100 }} /></TableCell><TableCell align="center"><Chip {...getStatusProps(endpoint.externalHealth)} size="small" sx={{ width: 100 }} /></TableCell><TableCell align="right"><Box display="flex" alignItems="center" justifyContent="flex-end"><Typography variant="body2" sx={{ mr: 1, minWidth: '40px', textAlign: 'right' }}>{endpoint.internalLatency !== null ? endpoint.internalLatency : 'N/A'}</Typography>{endpoint.internalLatency !== null && (<LatencyBar currentLatency={endpoint.internalLatency} baselineLatency={endpoint.baselineLatency} health={endpoint.internalHealth} themeMode={themeMode} />)}{getTrendIcon(getTrend(endpoint.internalLatencyHistory))}</Box></TableCell><TableCell align="right"><Box display="flex" alignItems="center" justifyContent="flex-end"><Typography variant="body2" sx={{ mr: 1, minWidth: '40px', textAlign: 'right' }}>{endpoint.externalLatency !== null ? endpoint.externalLatency : 'N/A'}</Typography>{endpoint.externalLatency !== null && (<LatencyBar currentLatency={endpoint.externalLatency} baselineLatency={endpoint.baselineLatency} health={endpoint.externalHealth} themeMode={themeMode} />)}{getTrendIcon(getTrend(endpoint.externalLatencyHistory))}</Box></TableCell><TableCell align="right">{endpoint.baselineLatency}</TableCell><TableCell align="center">{endpoint.lastChecked ? endpoint.lastChecked.toLocaleString() : 'N/A'}</TableCell></TableRow>
              ))}
            </TableBody>
          </Table>
        </TableContainer>
      </CardContent>
    </Card>
  );
};

const NotificationAlerting: React.FC = () => (
  <Card>
    <CardContent>
      <Typography variant="h5" gutterBottom>
        Notification & Alerting
      </Typography>
      <Typography variant="body1" paragraph>
        This Logic App can be configured to send summary status and alerts via various notification mechanisms based on defined thresholds:
      </Typography>
      <Alert severity="info" sx={{ mb: 1 }}>
        <AlertTitle>Email Notifications</AlertTitle>
        Automated emails can be sent to designated recipients or distribution lists for critical alerts (Red status) and daily/weekly performance summaries. This ensures key stakeholders are immediately informed of incidents.
      </Alert>
      <Alert severity="info" sx={{ mb: 1 }}>
        <AlertTitle>RSS Feed</AlertTitle>
        A dedicated RSS feed can be published, allowing users or other monitoring systems to subscribe and receive real-time updates on endpoint health changes, providing a low-friction subscription model.
      </Alert>
      <Alert severity="info">
        <AlertTitle>Subscription-based Notifications</AlertTitle>
        Integration with popular communication and incident management platforms (e.g., Slack, Microsoft Teams, PagerDuty, Opsgenie) can be established to push alerts directly to relevant channels or on-call teams for rapid response.
      </Alert>
    </CardContent>
  </Card>
);

const AutomatedSelfHealingActions: React.FC = () => (
  <Card>
    <CardContent>
      <Typography variant="h5" gutterBottom>
        Automated Self-Healing Actions
      </Typography>
      <Typography variant="body1" paragraph>
        Under predefined conditions (e.g., an endpoint remains 'Red' for more than 5 minutes), this Logic App can trigger automated self-healing resolutions to mitigate issues without manual intervention. These actions are crucial for maintaining application availability:
      </Typography>
      <Alert severity="warning" sx={{ mb: 1 }}>
        <AlertTitle>Auto-Restart Application Service</AlertTitle>
        If an endpoint consistently shows a 'Red' status due to application-level errors (e.g., unhandled exceptions, memory leaks), the Logic App can automatically trigger a restart of the associated application service to clear its state.
      </Alert>
      <Alert severity="warning" sx={{ mb: 1 }}>
        <AlertTitle>IIS App Pool Recycle</AlertTitle>
        For web applications hosted on IIS, if an endpoint becomes unresponsive or shows degraded performance, the Logic App can initiate an automatic recycle of the relevant IIS application pool, often resolving minor resource contention issues.
      </Alert>
      <Alert severity="warning">
        <AlertTitle>Failover to Secondary Instance</AlertTitle>
        In a multi-instance or high-availability setup, if a primary instance's API endpoint consistently fails, the Logic App could trigger an automated failover to a healthy secondary instance, redirecting traffic and minimizing downtime.
      </Alert>
      <Typography variant="body2" color="textSecondary" sx={{ mt: 2 }}>
        Note: The specific automation steps would involve secure API integrations with cloud providers' APIs (e.g., Azure Resource Manager, AWS CloudWatch/Lambda, GCP Cloud Functions) or on-premise orchestration tools and runbooks.
      </Typography>
    </CardContent>
  </Card>
);

// Navigation component
interface SidebarNavProps {
  onSelectView: (view: string) => void;
  activeView: string;
  themeMode: 'dark' | 'light';
}

const SidebarNav: React.FC<SidebarNavProps> = ({ onSelectView, activeView, themeMode }) => {
  const currentTheme = themeMode === 'light' ? lightTheme : darkTheme;
  const navItems = [
    { id: 'table', text: 'Endpoint Table', icon: <TableChartIcon /> },
    { id: 'grid', text: 'API Status Grid', icon: <GridOnIcon /> },
    { id: 'error_trends', text: 'Error Trends', icon: <DeveloperBoardIcon /> },
    { id: 'summary', text: 'Overall Summary', icon: <DashboardIcon /> },
    { id: 'notifications', text: 'Notifications', icon: <NotificationsIcon /> },
    { id: 'selfHealing', text: 'Self-Healing', icon: <AutoFixHighIcon /> },
  ];

  return (
    <Box sx={{ width: 168, flexShrink: 0, bgcolor: 'background.paper', borderRight: 1, borderColor: 'divider', height: '100vh', position: 'sticky', top: 0, p: 1 }}>
      <Typography variant="subtitle1" sx={{ mb: 2, fontWeight: 'bold', color: currentTheme.palette.primary.main, fontSize: '1rem', justifyContent: 'center', textAlign: 'center' }}>
        Views
      </Typography>
      <List>
        {navItems.map((item) => (
          <ListItem key={item.id} disablePadding>
            <ListItemButton
              selected={activeView === item.id}
              onClick={() => onSelectView(item.id)}
              sx={{
                borderRadius: 2,
                flexDirection: 'column',
                alignItems: 'center',
                justifyContent: 'center',
                py: 1.5,
                '&.Mui-selected': {
                  backgroundColor: currentTheme.palette.primary.light,
                  color: currentTheme.palette.primary.contrastText,
                  '& .MuiListItemIcon-root': { color: currentTheme.palette.primary.contrastText }
                },
                '&:hover': {
                  backgroundColor: currentTheme.palette.action.hover,
                },
                color: currentTheme.palette.text.primary,
              }}
            >
              <ListItemIcon sx={{ minWidth: 40, color: 'inherit', mb: 0.5 }}>
                {item.icon}
              </ListItemIcon>
              <ListItemText
                primary={
                  <Typography variant="caption" sx={{ fontSize: '0.75rem', textAlign: 'center', lineHeight: 1.2, color: 'inherit' }}>
                    {item.text}
                  </Typography>
                }
                disableTypography={true}
              />
            </ListItemButton>
          </ListItem>
        ))}
      </List>
    </Box>
  );
};

// Function to format a Date object toYYYY-MM-DD string
const formatDateToYYYYMMDD = (date: Date | null): string => {
  if (!date) return '';
  const year = date.getFullYear();
  const month = (date.getMonth() + 1).toString().padStart(2, '0');
  const day = date.getDate().toString().padStart(2, '0');
  return `${year}-${month}-${day}`;
};

// Custom Mini Trend Graph component
interface MiniTrendGraphProps {
  history: HistoryDataPoint[];
  label: string;
  unit: string;
  color: string;
  appliedStartDate: Date | null;
  appliedEndDate: Date | null;
  themeMode: 'light' | 'dark';
}

const MiniTrendGraph: React.FC<MiniTrendGraphProps> = ({ history, label, unit, color, appliedStartDate, appliedEndDate, themeMode }) => {
  const currentTheme = themeMode === 'light' ? lightTheme : darkTheme;
  // Filter history based on selected date range
  const filteredHistory = useMemo(() => {
    if (!appliedStartDate || !appliedEndDate) {
      return history;
    }
    const start = appliedStartDate;
    const end = appliedEndDate;

    return history.filter(point =>
      point.timestamp.getTime() >= start.getTime() &&
      point.timestamp.getTime() <= end.getTime()
    );
  }, [history, appliedStartDate, appliedEndDate]);

  if (filteredHistory.length === 0) {
    return (
      <Box sx={{ width: '100%', height: 100, display: 'flex', alignItems: 'center', justifyContent: 'center', color: 'text.secondary', border: '1px dashed', borderColor: currentTheme.palette.grey[400], borderRadius: 2, p: 2 }}>
        <Typography variant="body2">No data available for selected date range.</Typography>
      </Box>
    );
  }

  const chartData = filteredHistory.map(point => ({
    value: point.value,
    date: point.timestamp.toLocaleDateString('en-US', { year: 'numeric', month: 'short', day: 'numeric' }),
    fullDate: point.timestamp.toLocaleDateString('en-US', { year: 'numeric', month: 'short', day: 'numeric' }),
  }));

  return (
    <Box sx={{ width: '100%', height: 100 }}>
      <ResponsiveContainer width="100%" height="100%">
        <AreaChart data={chartData} margin={{ top: 5, right: 0, left: 0, bottom: 5 }}>
          <defs>
            <linearGradient id={`color${label}`} x1="0" y1="0" x2="0" y2="1">
              <stop offset="5%" stopColor={color} stopOpacity={0.8}/>
              <stop offset="95%" stopColor={currentTheme.palette.grey[300]} stopOpacity={0}/>
            </linearGradient>
          </defs>
          <RechartsTooltip
            labelFormatter={(labelValue, payload) => {
              if (payload && payload.length > 0 && payload[0].payload && payload[0].payload.fullDate) {
                return `Date: ${payload[0].payload.fullDate}`;
              }
              return `Date: ${labelValue}`;
            }}
            formatter={(value) => [`${value} ${unit}`, label]}
            contentStyle={{ backgroundColor: currentTheme.palette.background.paper, border: `1px solid ${currentTheme.palette.divider}` }}
            labelStyle={{ color: currentTheme.palette.text.primary }}
            itemStyle={{ color: currentTheme.palette.text.secondary }}
          />
          <Area type="monotone" dataKey="value" stroke={color} fillOpacity={1} fill={`url(#color${label})`} strokeWidth={2} dot={false} />
        </AreaChart>
      </ResponsiveContainer>
    </Box>
  );
};

// ErrorRateTrends component
interface ErrorRateTrendsProps {
  endpoints: Endpoint[];
  appliedStartDate: Date | null;
  appliedEndDate: Date | null;
  themeMode: 'light' | 'dark';
}

const ErrorRateTrends: React.FC<ErrorRateTrendsProps> = ({ endpoints, appliedStartDate, appliedEndDate, themeMode }) => {
  const currentTheme = themeMode === 'light' ? lightTheme : darkTheme;
  return (
    <Card>
      <CardContent>
        <Typography variant="h5" gutterBottom>
          Error Rate Trends Over Time
        </Typography>
        <Box sx={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fit, minmax(300px, 1fr))', gap: 3 }}>
          {endpoints.map(endpoint => (
            <Card key={endpoint.id} variant="outlined" sx={{ borderRadius: 2 }}>
              <CardContent>
                <Typography variant="h6" gutterBottom sx={{ mb: 1 }}>
                  {endpoint.name}
                </Typography>
                <Typography variant="body2" color="textSecondary" sx={{ mb: 2 }}>
                  Server: {endpoint.serverName}
                </Typography>
                <MiniTrendGraph
                  history={endpoint.errorRateHistory}
                  label="Error Rate"
                  unit="%"
                  color={currentTheme.palette.error.main}
                  appliedStartDate={appliedStartDate}
                  appliedEndDate={appliedEndDate}
                  themeMode={themeMode}
                />
                <Typography variant="body2" component="span" sx={{ mt: 1 }}>
                  Current Error Rate: <Chip label={`${endpoint.errorRate}%`} size="small" color={endpoint.errorRate > 10 ? 'error' : endpoint.errorRate > 3 ? 'warning' : 'success'} />
                </Typography>
              </CardContent>
            </Card>
          ))}
        </Box>
      </CardContent>
    </Card>
  );
};

const App: React.FC = () => {
  const [endpoints, setEndpoints] = useState<Endpoint[]>(initialEndpoints);
  const [loading, setLoading] = useState<boolean>(true);
  const [activeView, setActiveView] = useState<string>('table');
  const [startDateString, setStartDateString] = useState<string>('');
  const [endDateString, setEndDateString] = useState<string>('');
  const [appliedStartDate, setAppliedStartDate] = useState<Date | null>(null);
  const [appliedEndDate, setAppliedEndDate] = useState<Date | null>(null);
  const [serverNameFilter, setServerNameFilter] = useState<string>('');
  const [themeMode, setThemeMode] = useState<'light' | 'dark'>('dark');
  const [selectedTimeRange, setSelectedTimeRange] = useState<string>(''); // Reintroduced state

  const currentTheme = useMemo(() => themeMode === 'light' ? lightTheme : darkTheme, [themeMode]);

  const uniqueServerNames = useMemo(() => {
    const names = new Set(initialEndpoints.map(e => e.serverName));
    return Array.from(names).sort();
  }, []);

  useEffect(() => {
    const interval = setInterval(() => {
      setEndpoints((prevEndpoints) =>
        prevEndpoints.map((endpoint) => {
          const internalResult = simulateApiCall(endpoint.baselineLatency);
          const externalResult = simulateApiCall(endpoint.baselineLatency * 1.2);

          const now = new Date();

          // Update history arrays with new live data
          const newInternalHistory = [...endpoint.internalLatencyHistory, { value: internalResult.latency, timestamp: now }];
          if (newInternalHistory.length > MAX_HISTORY_POINTS) { // Use MAX_HISTORY_POINTS
            newInternalHistory.shift();
          }

          const newExternalHistory = [...endpoint.externalLatencyHistory, { value: externalResult.latency, timestamp: now }];
          if (newExternalHistory.length > MAX_HISTORY_POINTS) { // Use MAX_HISTORY_POINTS
            newExternalHistory.shift();
          }

          const newErrorRateHistory = [...endpoint.errorRateHistory, { value: internalResult.errorRate, timestamp: now }];
          if (newErrorRateHistory.length > MAX_HISTORY_POINTS) { // Use MAX_HISTORY_POINTS
            newErrorRateHistory.shift();
          }

          return {
            ...endpoint,
            internalLatency: internalResult.latency,
            externalLatency: externalResult.latency,
            internalHealth: internalResult.health,
            externalHealth: externalResult.health,
            // lastChecked is intentionally NOT updated here to allow historical filtering on it
            internalLatencyHistory: newInternalHistory,
            externalLatencyHistory: newExternalHistory,
            errorRate: internalResult.errorRate,
            traffic: internalResult.traffic,
            errorRateHistory: newErrorRateHistory,
          };
        })
      );
      setLoading(false);
    }, 3000);

    return () => clearInterval(interval);
  }, []);

  const totalEndpoints = endpoints.length;
  const healthyEndpoints = endpoints.filter(
    (e) => e.internalHealth === 'Green' && e.externalHealth === 'Green'
  ).length;
  const yellowEndpoints = endpoints.filter(
    (e) => e.internalHealth === 'Yellow' || e.externalHealth === 'Yellow'
  ).length;
  const redEndpoints = endpoints.filter(
    (e) => e.internalHealth === 'Red' || e.externalHealth === 'Red'
  ).length;

  const overallStatus = useMemo(() => {
    if (redEndpoints > 0) {
      return 'Critical';
    } else if (yellowEndpoints > 0) {
      return 'Degraded';
    } else if (healthyEndpoints === totalEndpoints && totalEndpoints > 0) {
      return 'Operational';
    } else {
      return 'Unknown';
    }
  }, [healthyEndpoints, yellowEndpoints, redEndpoints, totalEndpoints]);

  const getStatusProps = useCallback((health: 'Red' | 'Yellow' | 'Green' | 'Unknown') => {
    switch (health) {
      case 'Green':
        return { label: 'Healthy', color: 'success', icon: <CheckCircleOutlineIcon fontSize="small" /> };
      case 'Yellow':
        return { label: 'Degraded', color: 'warning', icon: <WarningAmberIcon fontSize="small" /> };
      case 'Red':
        return { label: 'Critical', color: 'error', icon: <ErrorOutlineIcon fontSize="small" /> };
      default:
        return { label: 'Unknown', color: 'default', icon: <HorizontalRuleIcon fontSize="small" /> };
    }
  }, []);

  const getTrendIcon = useCallback((trend: 'improving' | 'degrading' | 'stable' | 'unknown') => {
    switch (trend) {
      case 'improving':
        return <Tooltip title="Improving"><ArrowUpwardIcon color="success" fontSize="small" sx={{ ml: 0.5 }} /></Tooltip>;
      case 'degrading':
        return <Tooltip title="Degrading"><ArrowDownwardIcon color="error" fontSize="small" sx={{ ml: 0.5 }} /></Tooltip>;
      case 'stable':
        return <Tooltip title="Stable"><HorizontalRuleIcon color="action" fontSize="small" sx={{ ml: 0.5 }} /></Tooltip>;
      default:
        return null;
    }
  }, []);

  const handleApplyFilter = () => {
    const now = new Date();
    let newAppliedStartDate: Date | null = null;
    let newAppliedEndDate: Date | null = null;

    if (selectedTimeRange) {
      newAppliedEndDate = now; // End date is current time for time ranges
      switch (selectedTimeRange) {
        case '1min':
          newAppliedStartDate = new Date(now.getTime() - 1 * 60 * 1000);
          break;
        case '3min':
          newAppliedStartDate = new Date(now.getTime() - 3 * 60 * 1000);
          break;
        case '5min':
          newAppliedStartDate = new Date(now.getTime() - 5 * 60 * 1000);
          break;
        case '1hour':
          newAppliedStartDate = new Date(now.getTime() - 60 * 60 * 1000);
          break;
        case '3hours':
          newAppliedStartDate = new Date(now.getTime() - 3 * 60 * 60 * 1000);
          break;
        case '1day': // Last 24 hours
          newAppliedStartDate = new Date(now.getTime() - 24 * 60 * 60 * 1000);
          break;
        case '1week': // Last 7 days
          newAppliedStartDate = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
          break;
        case '1month': // Last 30 days
          newAppliedStartDate = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);
          break;
        default:
          break;
      }
      // Clear manual date inputs when a time range is selected
      setStartDateString('');
      setEndDateString('');
    } else {
      // Apply manual date filter if no time range is selected
      if (startDateString) {
        newAppliedStartDate = new Date(startDateString);
        newAppliedStartDate.setHours(0, 0, 0, 0); // Start of the day
      }
      if (endDateString) {
        newAppliedEndDate = new Date(endDateString);
        newAppliedEndDate.setHours(23, 59, 59, 999); // End of the day
      }
    }

    setAppliedStartDate(newAppliedStartDate);
    setAppliedEndDate(newAppliedEndDate);
  };

  const handleClearFilters = () => {
    setStartDateString('');
    setEndDateString('');
    setAppliedStartDate(null);
    setAppliedEndDate(null);
    setServerNameFilter('');
    setSelectedTimeRange(''); // Clear time range as well
  };

  // Filter endpoints by server name first
  const filteredEndpointsByServer = useMemo(() => {
    if (!serverNameFilter) {
      return endpoints;
    }
    return endpoints.filter(endpoint => endpoint.serverName === serverNameFilter);
  }, [endpoints, serverNameFilter]);

  // Then apply the date range filter based on endpoint.lastChecked
  const displayEndpoints = useMemo(() => {
    let currentEndpoints = filteredEndpointsByServer;

    if (appliedStartDate && appliedEndDate) {
      currentEndpoints = currentEndpoints.filter(endpoint =>
        endpoint.lastChecked &&
        endpoint.lastChecked.getTime() >= appliedStartDate.getTime() &&
        endpoint.lastChecked.getTime() <= appliedEndDate.getTime()
      );
    }
    return currentEndpoints;
  }, [filteredEndpointsByServer, appliedStartDate, appliedEndDate]);


  const toggleTheme = () => {
    setThemeMode((prevMode) => (prevMode === 'light' ? 'dark' : 'light'));
  };

  if (loading) {
    return (
      <ThemeProvider theme={currentTheme}>
        <CssBaseline />
        <Box sx={{ display: 'flex', justifyContent: 'center', alignItems: 'center', height: '100vh', flexDirection: 'column' }}>
          <CircularProgress size={60} sx={{ mb: 2 }} />
          <Typography variant="h6" color="textSecondary">Loading API Status...</Typography>
        </Box>
      </ThemeProvider>
    );
  }

  return (
    <ThemeProvider theme={currentTheme}>
      <CssBaseline />
      <Box sx={{ display: 'flex', minHeight: '100vh', bgcolor: 'background.default' }}>
        <SidebarNav onSelectView={setActiveView} activeView={activeView} themeMode={themeMode} />
        <Container maxWidth="xl" sx={{ flexGrow: 1, p: 3, overflowY: 'auto' }}>
          <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 4 }}>
            <Typography variant="h4" component="h1" gutterBottom sx={{ fontWeight: 'bold', color: currentTheme.palette.text.primary }}>
              API Monitoring Dashboard
            </Typography>
            <IconButton onClick={toggleTheme} color="inherit">
              {themeMode === 'dark' ? <Brightness7Icon /> : <Brightness4Icon />}
            </IconButton>
          </Box>

          <Box sx={{ display: 'flex', gap: 2, mb: 4, alignItems: 'center', flexWrap: 'wrap' }}>
            <TextField
              label="Start Date"
              type="date"
              value={startDateString}
              onChange={(e) => { setStartDateString(e.target.value); setSelectedTimeRange(''); }}
              InputLabelProps={{ shrink: true }}
              sx={{ minWidth: 180 }}
            />
            <TextField
              label="End Date"
              type="date"
              value={endDateString}
              onChange={(e) => { setEndDateString(e.target.value); setSelectedTimeRange(''); }}
              InputLabelProps={{ shrink: true }}
              sx={{ minWidth: 180 }}
            />
            <FormControl sx={{ minWidth: 180 }}>
              <InputLabel id="time-range-select-label">Time Range</InputLabel>
              <Select
                labelId="time-range-select-label"
                id="time-range-select"
                value={selectedTimeRange}
                label="Time Range"
                onChange={(e) => { setSelectedTimeRange(e.target.value as string); setStartDateString(''); setEndDateString(''); }}
                sx={{ borderRadius: 2 }}
              >
                <MenuItem value="">
                  <em>None</em>
                </MenuItem>
                <MenuItem value="1min">Last 1 min</MenuItem>
                <MenuItem value="3min">Last 3 min</MenuItem>
                <MenuItem value="5min">Last 5 min</MenuItem>
                <MenuItem value="1hour">Last 1 hour</MenuItem>
                <MenuItem value="3hours">Last 3 hours</MenuItem>
                <MenuItem value="1day">Last 1 Day</MenuItem>
                <MenuItem value="1week">Last 1 Week</MenuItem>
                <MenuItem value="1month">Last 1 Month</MenuItem>
              </Select>
            </FormControl>
            <Button
              variant="contained"
              onClick={handleApplyFilter}
              sx={{ height: '56px', px: 3, borderRadius: 2 }}
            >
              Apply Filter
            </Button>
            <Button
              variant="outlined"
              onClick={handleClearFilters}
              sx={{ height: '56px', px: 3, borderRadius: 2 }}
            >
              Clear Filters
            </Button>
            <FormControl sx={{ minWidth: 200 }}>
              <InputLabel id="server-name-select-label">Filter by Server</InputLabel>
              <Select
                labelId="server-name-select-label"
                id="server-name-select"
                value={serverNameFilter}
                label="Filter by Server"
                onChange={(e) => setServerNameFilter(e.target.value as string)}
                sx={{ borderRadius: 2 }}
              >
                <MenuItem value="">
                  <em>All Servers</em>
                </MenuItem>
                {uniqueServerNames.map(name => (
                  <MenuItem key={name} value={name}>{name}</MenuItem>
                ))}
              </Select>
            </FormControl>
          </Box>

          {activeView === 'summary' && (
            <OverallSummaryStatus
              totalEndpoints={displayEndpoints.length}
              healthyEndpoints={displayEndpoints.filter(
                (e) => e.internalHealth === 'Green' && e.externalHealth === 'Green'
              ).length}
              yellowEndpoints={displayEndpoints.filter(
                (e) => e.internalHealth === 'Yellow' || e.externalHealth === 'Yellow'
              ).length}
              redEndpoints={displayEndpoints.filter(
                (e) => e.internalHealth === 'Red' || e.externalHealth === 'Red'
              ).length}
              overallStatus={overallStatus}
            />
          )}

          {activeView === 'table' && (
            <IndividualEndpointStatusTable
              endpoints={displayEndpoints}
              getStatusProps={getStatusProps}
              getTrendIcon={getTrendIcon}
              appliedStartDate={appliedStartDate}
              appliedEndDate={appliedEndDate}
              themeMode={themeMode}
            />
          )}

          {activeView === 'grid' && (
            <OverallApiStatusGrid
              endpoints={displayEndpoints}
              appliedStartDate={appliedStartDate}
              appliedEndDate={appliedEndDate}
              themeMode={themeMode}
            />
          )}

          {activeView === 'error_trends' && (
            <ErrorRateTrends
              endpoints={displayEndpoints}
              appliedStartDate={appliedStartDate}
              appliedEndDate={appliedEndDate}
              themeMode={themeMode}
            />
          )}

          {activeView === 'notifications' && <NotificationAlerting />}
          {activeView === 'selfHealing' && <AutomatedSelfHealingActions />}
        </Container>
      </Box>
    </ThemeProvider>
  );
};

export default App;
